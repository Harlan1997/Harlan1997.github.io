<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++基础</title>
    <url>/2021/03/20/C-C++%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h2><ul>
<li>nullptr</li>
<li>auto</li>
<li>右值引用 移动语义</li>
<li>正则表达式</li>
</ul>
<h1 id="struct-跟-class的区别"><a href="#struct-跟-class的区别" class="headerlink" title="struct 跟 class的区别"></a>struct 跟 class的区别</h1><p>struct是数据结构实现体，而class是对象实现体<br>最明显的一个区别是访问控制，struct是public的，class是private的</p>
<h2 id="变量和对象"><a href="#变量和对象" class="headerlink" title="变量和对象"></a>变量和对象</h2><ul>
<li>变量：内存在代码中可视化的一个符号</li>
<li>对象：对象是指一块能存储数据并具有某种类型的内存空间</li>
</ul>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><ul>
<li>左值：表示可以取地址的，有名字的，非临时的对象，如非匿名对象，函数返回的引用，const对象等。</li>
<li>右值：不能取地址的，没有名字的，临时的表达式，如立即数，函数返回值等。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>定义：是给变量起的别名</li>
<li>用法：<code>Type &amp;name = var</code>。声明引用时，必须用其它的变量进行初始化(说明引用是个常量)。引用作为函数的参数声明时不进行初始化。</li>
<li>为什么需要引用？<br>引用作为其它变量的别名而存在，在一些场合可以替代指针。相对于指针来说引用具有更好的可读性和实用性。</li>
<li>引用的本质：指针常量</li>
</ul>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。相关代码执行完匿名对象就消失了。</p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>就是对一个左值进行引用的类型。左值引用通常不能绑定右值。左值引用它可以接受非常量左值、常量左数值、右值对其进行初始化。左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改据，因为其被const修饰成常量引用了。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用是C++ 11新增的特性，右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。右值引用跟常引用的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。右值引用通常不能绑定左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p>
<ul>
<li>为什么需要右值引用？<br>右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，再进行使用，这是很浪费时间的。</li>
<li>转移语义：将右值引用绑定到左值，避免多余的内存拷贝。std::move()</li>
<li>完美转发：只有在需要的时候，才调用复制构造函数，左值被转发为左值，右值被转发为右值。std::forward()</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>储存地址的变量</p>
<ul>
<li>指针跟引用的区别<br>引用是指针常量，地址不能改变。指针没有这个限制。</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是指向动态分配（堆）对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。智能指针包括：shared_ptr， unique_ptr， weak_ptr。<br>share_ptr：多个指针指向同一个对象，当最后一个指针离开作用域时，内存才会释放。<br>unique_ptr：资源只能被一个unique_ptr占有，当unique_ptr离开作用域，内存会被释放。如果资源被其它资源重写了，之前拥有的资源也会被释放。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物抽象成的类。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>消息以多种形态显示的能力，多态以封装和继承为基础。<br>C++多态实现：</p>
<ul>
<li>重载多态</li>
<li>子类型多态</li>
<li>参数多态</li>
<li>强制多态</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在某基类中声明为virtual，并在一个或多个派生类中被重新定义的成员函数。在基类中可以实现，可以不实现，它的作用是让这个函数能在子类中被覆盖，子类可以不重写。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>只是一个接口，基类中不能有实现，子类要实现才可以实例化。</p>
<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>如果编译器发现基类中有虚函数，会自动为每个含有虚函数的类生成一份虚函数表，该表是一个一维数组，保存了虚函数的入口地址。编译器会在每个对象的前4个字节保存一个虚表指针，指向对象所属的虚表。在对象实例化时会</p>
<h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝 浅拷贝"></a>深拷贝 浅拷贝</h2><p>浅拷贝是对指针的拷贝<br>深拷贝是对指针和指针所指向内容</p>
<h2 id="内存中堆栈的区别"><a href="#内存中堆栈的区别" class="headerlink" title="内存中堆栈的区别"></a>内存中堆栈的区别</h2><p>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文<br>堆：般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>basic quantum theory</title>
    <url>/2021/03/06/basic-quantum-theory/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当年在上大学物理的时候的课程项目要求每个人都做一下物理学前沿知识的报告，我的小组选了Quantum Computation这一个课题。在这个报告中我主要负责Quantum Computation涉及到的一些基本的Quantum Mechanics的知识，其中的大部分内容总结自Dirac的《The Principles of Quantum Mechanics》和量子计算的bible《Quantum Computation and Quantum Information》。这是我这篇报告的由来。<br><span id="more"></span></p>
<h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Quantum mechanics is the science of the very small. It explains the behavior of matter and its interactions with energy on the scale of atoms and subatomic particles. By contrast, classical physics only explains matter and energy on a scale familiar to human experience, including the behavior of astronomical bodies such as the Moon. Classical physics is still used in much of modern science and technology. However, towards the end of the 19th century, scientists discovered phenomena in both the large (macro) and the small (micro) worlds that classical physics could not explain.The desire to resolve inconsistencies between observed phenomena and classical theory led to two major revolutions in physics that created a shift in the original scientific paradigm: the theory of relativity and the development of quantum mechanics</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>As in classical mechanics, the state of a particle at any given time is specified by two variables position an momentum. If we know these quantities, we can get all the information of the system we want to measure. For example, energy is just some function of position and momentum. We can calculate it if we know the position and momentum. However, this is impossible in quantum mechanics. In atom scale, according to the uncertainty principle, we can’t specify the position and momentum at the same time. How can can we specify the state of a system? By the Copenhagen interpretation, a state of a particle is completely specified by a complex wave function $\ket{\psi}$ and it is described to be a probability amplitude, whose square modulus gives the probability density of finding the particle at point x at time t.</p>
<p>A mixture of quantum states is also a quantum state. Quantum states that cannot be writtten as a mixtrue of other states are called pure quantum states, all other states are called mixed quantum state.</p>
<p>Mathematically, a pure quantum state can be represented by a ray in a Hilbert space over the complex numbers. The ray is a set of nonzero vecctor differing by just a complex factor; any of them can be chosen as a state vector to represent the ray and thus the state. A unit vector is usually picked, but its phase factor can be chosen freely anyway. Nevertheless, such factors are important when state vectors are added together to form a superposition.</p>
<p>A mixed quantum state corresponds to a probabilistic mixture of pure state; however, different distribution of pure states can generate equavalent mixed states. Mixed states are describe by density matrices. A pure state can also be recast as a density matrix; in this way, pure statee can be represented as a subset of more general mixed states.</p>
<h3 id="Bracket-Notaion"><a href="#Bracket-Notaion" class="headerlink" title="Bracket Notaion"></a>Bracket Notaion</h3><p>The absence of a state is represented by the null vector $\ket{0}$ in ket space. The null vector has the fairly obvious property that. $\ket{A}+\ket{0}=\ket{A}$</p>
<p>Now we know that any plane polarized state of a photon can be represented as a linear superposition of two orthogonal polarization states in wichi the weights are real numbers. Suppose we want to construct a circular polarized photon state. Remind that a circularly polarized wave is a superposition of two waves of equal amplitude, plane polarized in the X-direction and a photon polarized in the y-direction, with equal weights given to the two states. To descrive a circularly polarized photon, we can use complex numbers to simultaneously represent the weighting and relative phase phase in a linear superposition. Suppose state B represents the photon polarizing in the x-direction, state C represents the photon polarizing in the y-direction, written as $\ket{B}+i\ket{C}$. Then we can conclude: a general elliptically polarized photon is represeted by $c_1\ket{B}+c_2\ket{C}$ where $c_1 and c_2$ are complex numbers. It implies that a ket space must be a complex vector space.</p>
<p>Any ket vector that is expressible linearly in terms of cortain orthers is said to be dependent on them. Likewise, a set of ket vecotrs are termed independent if none of them are expressible linearly interms of them. The dimension of a ket space is equivalent to the number of independent ket vectors it contains. If there are N independent states then the possible states of the system are represtned as an N-dimensional ket space. Remind some microscopic sysyems have an infinite number of independent states(e.g.,a particle in an infinite, one dimensional, potential well). The possible states are represented as a ket in a ket space whose dimention are infinite.<br>In conclusion, the state of a general microspopic system can be represented as a complex vector space of infinite dimension. Such a space is called  Hilbert space.</p>
<p>Imagine a general functional, label F, acting on a general ket vector, lavel A, and spitting out a general complex number $\phi_A$. This process is represented by writing $\bra{F}(\ket{A})=\phi_A$. Suppose there is a linear functional functionals, satisfies $\bra{F}(\ket{A}+\ket{B})=\braket{F|A}+\braket{F|B}$ where $\ket{A}$ and $\ket{B}$ are any two kets in a given Hilbert space. In a Hilbert space, a general ket vector can be written as $\sum_{i=1}^Na_i\ket{i}$ where $\ket{i}$(i=1,2,3,…,n) represents n independent ket vector in this space, $a_i$ is an arbitrary complex number. Then the functional $\braket{F|A}=\sum_{i=1}^Nf_ia_i$ where $f_i$ are a set of complex numbers relating to the functional. Define n basis of functionals $\bra{i}$ (i=i,2,3,…,n) which satisfy $\braket{i|j}=\delta_{ij}$.Then we get $\bra{F}=\sum_{i=1}^Nf_i\bra{i}$. This implies that the set of all possible linear functionals acting on a n-dimentional ket space is itself an n-dimensional vector space. This type of vector space is called bra space. The vector in this space are called bra vectors. Bra space is an example of what mathematicians call a dual space.  It is dual to the original ket space.</p>
<p>For a general ket vector $A$, the corresponding bra is written as <script type="math/tex">\bra{A}=\sum_{i=1}^Na_i^*\bra{i}</script> where $a_i^*$ are the complex conjugate of $a_i$. Given a ket $\ket{A}$, which is not the null ket, we can define a normalized $\ket{\tilde{A}}$ where $\braket{\tilde{A}|\tilde{A}}=1$. Since $\ket{A}$ and $c\ket{A}$ represent the same physical state (we can not form a new state by superposing a state with itself), it makes sense to require that all kets corresponding to physical states have unit norms.</p>
<h3 id="Wave-Function"><a href="#Wave-Function" class="headerlink" title="Wave Function"></a>Wave Function</h3><p>A wave function in quantum physics is a mathematical description of the quantum state of an isolated quantum system. The wave function is a complex-valued probability amplitude, whose square modulus gives the probability density at a point x. Since we have wave function is complex value, only its relative phase and relative magnitude can be measured. We have to apply quatum operator, whose eigenvalues corresponding to sets of possible results of measurements, to the wave function $\psi$ an calculate the statistical distribution for measurable quantities. The most common symbols for a wave function are the Greek letter $\psi$</p>
<p>Given a basis kets $\ket{k_i}$ of Hilbert space, any ket $\ket{\psi}$ can be written as $\ket{\psi}=\sum_{i=1}^nc_i\ket{k_i}$ where $c_i$ are complex numbers. If the basis is chosen to be orthonormal, then $c_i=\braket{k_i|\psi}$. If $\ket{k_i}$ is eigenstates of an observable with eigenvalue $c_i$, and the observable is measured on the normalized state$\ket{\psi}$, then the probability that the result of the measurement is $k_i$ is $|c_i|^2$.</p>
<p>A particular importan example is the position basis, which is the basis consisting of eigenstates $\ket{\textbf{r}}$ with eigenvalue $\textbf{r}$ of the observable which corresponds to measure position. If these eigenstates are nondegenerate, then the ket $\ket{\psi}$ is associate with a complex-value wave function of there-dimentional space $\psi(\textbf{r})=\braket{\textbf{r}|\psi}$. Simlilarly, the probability density of the particle being found at position $\textbf{r}$ is $|\psi(\textbf{r})|^2$ and the normalized state have $\int d^3\textbf{r}|\psi(\textbf{r})|^2=1$.</p>
<h3 id="Superposition"><a href="#Superposition" class="headerlink" title="Superposition"></a>Superposition</h3><p>If we take any atomic system, there will be many possible motions of the particles consistent with the law of forcee. Each such motion is called a state of the system. A state of a system may be defined as an undistrubuted motion that is whithout mutual interference or contradiction. The general principle of superposition of quantum mechanics applied to the states of any one dynamical system. It requires us to assume that between these states there exist peculiar repationships wuch that whenever the system is definitely in one state we can consider as being partly in each of two or more other states.</p>
<p>When a state is formed by the superposition of other states. As we obserbe, the result shows that the system sometimes in one state, sometimes in another state. The result can’t be determined though the obseervation made. It is the law of nature. The principle was described by Paul Dirac as follows:</p>
<blockquote>
<p>The non-classical nature of the superposition process is brought out clearly if we consider the superpostion of two states, A and B, such that there exists an observation which, when made on the system in states A, is certain to lead to one particular result a.And when made on the system in state B is certain to lead to some different result b. What will be the result of the observation when made on the system in the superposed state? The answer is that  the result will be somtimes a and sometimes b, according to a probability law depending on the relative weights of A and B in the superposition process. It will never be different from both a and b. The intermediate character of the state formed by superposition thus expresses itself throught  the probability of a particular result for an observation being intermediate between the corresponding probabilities for the original states, not throught the result itself being intemediate between the corresponding result for the original states.</p>
</blockquote>
<p>As an example, suppose there are two eigenstates $\ket{\psi_i}$ and $\ket{\psi_2}$, the superposition of them is their linear combination $c_1\ket{\psi_1}+c_2\ket{\psi_2}$. If we make an observation on the system. The wave function of the system will collapse to an eigenstate of the observable randomly. The probability ralating to the eigenstate $\ket{\psi_1}$ is $|c_1|^2$, the probability relating to eigensteate $c_2$ is $|c_2|^2$. </p>
<h3 id="Entanglement"><a href="#Entanglement" class="headerlink" title="Entanglement"></a>Entanglement</h3><p>By definition, quantum entanglement is a physical phenomenon which occurs when pairs or groups of particles are generated or interact in ways such that the quantum state of each that the quantum state of each particle cannot be described independently of the state of the others, even when the particles are separated by large distance.</p>
<p>So far, we have assumed that the system is made of a single component. Suppose a system is made of two component: one in a Hilbert space $H_1$ and another component in another Hilber space $H_2$. Then the system as a whole live in a Hilbert space $H=H_1\otimes H_2$. The general vector in this space is written as $\ket{\psi}=\sum_{i,j}c_{ij}\ket{e_1,i}\otimes\ket{e_2,j}$ where $\ket{e_a,i}$(a=1,2) is an orthonormal basis in $H_a$ and $\sum_{i,}|c_{ij}|^2=1$. A state $\ket{\psi}\in H$ written as a tensor product of two vector $\ket{\psi}=\ket{\psi_1}\otimes\ket{\psi_2}$ is called a tensor product state or a separable state. Non-separable states are called entangle state.</p>
<p>The set of separate states have dimension $dimH_1+dimH_2$. The total space $H$ has dimension $dimH_1dimH_2$.When the dimension of original Hilbert space is large,we have $dimH_1dimH_2$&gt;$dimH_1+dimH_2$. Then most states in the total space are entangled.</p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>quantum mechanics</tag>
        <tag>quantum computation</tag>
      </tags>
  </entry>
  <entry>
    <title>“联邦学习下的安全矩阵分解论文笔记”</title>
    <url>/2021/03/07/%E2%80%9C%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E2%80%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大数据时代，数据是人工只能产业化中不可缺少的基石。随着数据的隐私和安全被越来越重视，很多国家都开始出台有关保护数据隐私的政策，这使得非常依赖数据的人工智能产业陷入了困境。如何在满足数据隐私、安全和监管要求的前提下，让人工智能系统能够更加高效、准确的共同使用各自的数据，是当前人工智能发展的一个重要课题。2016年，Google提出了Federated Learning(FL)的概念，旨在训练一个基于分布在各个用户的移动设备上个人信息的中心化模型。目前在FL上的工作已经有很多。本文将对FL在Matrix Factorization(MF)应用，Secure Federated Matrix Factorization进行介绍。</p>
<h2 id="隐私信息泄露"><a href="#隐私信息泄露" class="headerlink" title="隐私信息泄露"></a>隐私信息泄露</h2><p>对于推荐算法来说，拿MF来说，有两类数据是被暴露出来的，一类是用户的raw </p>
]]></content>
      <tags>
        <tag>Fedrated Learning, Matrix Factorization, Recommending System</tag>
      </tags>
  </entry>
  <entry>
    <title>后端知识点总结</title>
    <url>/2021/03/26/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ul>
<li>线性表</li>
<li>栈</li>
<li>队列</li>
<li>数组</li>
</ul>
<h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><ul>
<li>单链表(链表和数组的区别)</li>
<li>双向链表</li>
<li>循环链表(约瑟夫环)</li>
<li>双向循环链表</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>二叉树</li>
<li>二叉搜索树</li>
<li>AVL树</li>
<li>红黑树</li>
<li>B树</li>
<li>B+树</li>
</ul>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>邻接表</li>
<li>临界矩阵</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>堆排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li>顺序查找</li>
<li>二分查找</li>
<li>哈希查找</li>
<li>二叉树查找</li>
<li>红黑树查找</li>
<li>B/B+树查找</li>
</ul>
<h3 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h3><ul>
<li>BFS</li>
<li>DFS</li>
</ul>
<h3 id="其它算法"><a href="#其它算法" class="headerlink" title="其它算法"></a>其它算法</h3><ul>
<li>分治法</li>
<li>动态规划</li>
<li>贪心</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="什么是同步-什么是异步"><a href="#什么是同步-什么是异步" class="headerlink" title="什么是同步 什么是异步"></a>什么是同步 什么是异步</h2><p>同步：必须等对方回应我，才开始做下一件事情<br>异步：不必等对方回应我，我继续做我的事情</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的独立单位</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ul>
<li>管道</li>
<li>信号量</li>
<li>信号</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>资源调度的独立单位</p>
<h2 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h2><ul>
<li>锁 互斥锁 读写锁 自旋锁 条件变量</li>
<li>信号量</li>
<li>信号</li>
<li>屏障</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>有一个线程在对内存进行操作的时候，其他线程都不可以对这个内存地址进行操作</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>实现协作式多任务，可以在程序执行内部中断，转而执行其它协程</p>
<ul>
<li>跟线程的区别：效率比线程高，因为切换不需要开销。不需要线程的锁机制。</li>
</ul>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>计算机执行多个进程</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>先来先去</li>
<li>短作业优先调度</li>
<li>轮转法</li>
<li>多级反馈队列</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个进程中同时有多个线程正在执行</p>
<h2 id="多线程跟多进程的区别"><a href="#多线程跟多进程的区别" class="headerlink" title="多线程跟多进程的区别"></a>多线程跟多进程的区别</h2><ul>
<li>多进程：编程、调试简单，可靠性高，但创建、销毁、切换速度慢、内存资源占用高。</li>
<li>多线程：编程、调试复杂，可靠性差，但创建、销毁、切换速度快、内存资源占用低。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>多个进程互相等待对方资源，循环等待。</li>
</ul>
<h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul>
<li>资源互斥</li>
<li>资源不可剥夺</li>
<li>占有资源后还继续请求新的资源</li>
<li>环路等待</li>
</ul>
<h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>破坏四个必要条件之一即可。</p>
]]></content>
  </entry>
  <entry>
    <title>用Github pages和Hexo搭建自己的个人博客</title>
    <url>/2021/03/06/%E7%94%A8Github-pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pages.github.com/">Github Pages</a>是一个静态站点托管服务, 用户可以可以从Github直接获取HTML, CSS, Java Script文件, 用户可以用这些文件来发布网页。<br><a href="https://hexo.io/">Hexo.io</a>是一个基于Node.js的快速、简单、功能强大的博客框架。<br>本门将介绍如何使用Hexo + Github Pages搭建个人博客。<br><span id="more"></span></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载和安装Node.js和Git</p>
<ul>
<li>Node.js下载地址: <a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git下载地址: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<h2 id="Git连接Github"><a href="#Git连接Github" class="headerlink" title="Git连接Github"></a>Git连接Github</h2><p>打开Git Bash</p>
<ul>
<li>设置用户名和邮箱<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub邮箱&quot;</code></li>
<li>生成SSH密钥<br><code>ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot;</code></li>
<li>为Github账户添加SSH密钥<br>公钥默认保存在 <code>C:\Users\用户名\.ssh</code>目录中, 用记事本打开 id_rsa.pub，复制内容。<br>点开github页面右上角头像,在Settings-&gt;SSH and GPG keys中点击New SSH key, 随便取个标题, 将复制的公钥粘贴进去, 点击Add SSH key </li>
<li>验证连接<br>打开Git Bash, 输入<br><code>ssh -T git@github.com</code><br>如果显示”You’ve successfully authenticated, but…”则连接成功</li>
</ul>
<h2 id="创建Github-Pages-Repository"><a href="#创建Github-Pages-Repository" class="headerlink" title="创建Github Pages Repository"></a>创建Github Pages Repository</h2><ul>
<li>点开github页面右上角旁边的加号，选择New repository</li>
<li>Repository name填上 <code>用户名.github.io</code></li>
<li>勾选 Add a README file</li>
<li>点击 Create repository</li>
</ul>
<h2 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h2><ul>
<li>找一个地方新建文件夹, 命名为hexo用来存放Hexo程序</li>
<li>打开Git CMD 进入到hexo的文件夹(注意这里不是Git Bash, 如果用Git Bash可能会碰到奇奇怪怪的问题)</li>
<li>npm安装hexo<br><code>npm install -g hexo-cli</code></li>
<li>hexo文件下载<br><code>hexo init</code></li>
<li>生成静态文件<br><code>hexo g</code></li>
<li>部署到本地服务器4000端口<br><code>hexo s</code><br>如果访问<code>http://localhost:4000</code>看到Hexo默认页面的Hello World则本地博客安装成功</li>
</ul>
<h2 id="部署Hexo到Github-Pages"><a href="#部署Hexo到Github-Pages" class="headerlink" title="部署Hexo到Github Pages"></a>部署Hexo到Github Pages</h2><ul>
<li>安装hexo-deployer-git<br><code>npm install hexo-deployer-git --save</code></li>
<li>修改博客配置文件<br>找到你的hexo文件夹里的_config.yml文件, 用记事本打开，在文件末尾找到Deployment部分，修改成：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: git@github.com:你的用户名&#x2F;你的用户名.github.io.git</span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure></li>
<li>部署<br><code>hexo d</code><br>打开你的博客站点<code>用户名.github.io</code>，如果跟本地静态一样显示Hexo的主题博客模板Hello World则部署成功</li>
</ul>
<h2 id="博客个性化设置"><a href="#博客个性化设置" class="headerlink" title="博客个性化设置"></a>博客个性化设置</h2><ul>
<li>主题更换<ol>
<li>到<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>里面找一款喜欢的主题，点进去找到安装说明。</li>
<li>比如我们想更换为nexT主题，我们只需要在Git Bash进入到hexo文件夹, 然后执行<br><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li>
<li>如果文件下载成功我们会在hexo/themes里面找到next文件夹<br>我们只需要在hexo的_configu.yml文件里面Theme: 后面的landscape改成next</li>
<li>执行<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code><br>然后我们就可以把我们的博客成nexT主题</li>
<li>后续的个性化设置比如增加社交联系方式，更换主题样式等等可以在theme\next_config.yml文件中修改，文件里注释写得很明白</li>
<li>如需要更多的优化，可以在<a href="https://zhuanlan.zhihu.com/p/33616481">Hexo搭建的GitHub博客之优化大全</a>中找到</li>
<li>要支持latex公式，可以按照<a href="https://wangcong.net/article/HexoWihLaTeX.html">Hexo中LaTeX公式渲染</a>中配置</li>
</ol>
</li>
</ul>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ul>
<li>在hexo目录下执行<br><code>hexo new &quot;name&quot;</code><br>该命令会在hexo\sorce_post下新建一个name.md文件,在这个md文件中写入内容</li>
<li>执行<br><code>hexo g</code><br><code>hexo d</code><br>则可以发布</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>短连接：连接-&gt;传输数据-&gt;关闭连接<br>长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ……….-&gt;直到一方关闭连接，多是客户端关闭连接。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。"><a href="#定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。" class="headerlink" title="定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。"></a>定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</h3><h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><ul>
<li>无连接</li>
<li>尽力可靠</li>
<li>没拥塞控制</li>
<li>首部开销小</li>
<li>支持一对多、多对多、多对一、一对一通信                            </li>
</ul>
<h2 id="滑窗协议"><a href="#滑窗协议" class="headerlink" title="滑窗协议"></a>滑窗协议</h2><p>发送端窗口里左边是已发送但未确认，右边是未发送。发送端一次性发多个分组，接收方只能对按序到达的分组中序列号最高的分组给出确认。如果没有发生丢失或超时，接收方不再保留按序保留的分组，接收端窗口向前移动，同时向发送端发送确认。发送端收到确认之后窗口也向前移动。如果接收端没有收到按序到达的分组，接收端会对按序到达序列号最高的分组给出确认。发送端收到确认移动窗口后，在一段时间后还没有收到接收端的确认，发送端就会重传这部分数据，直到收到确认为止。</p>
<h2 id="GET-POST登陆上的区别"><a href="#GET-POST登陆上的区别" class="headerlink" title="GET POST登陆上的区别"></a>GET POST登陆上的区别</h2><ul>
<li>GET是从服务器上获取数据，GET请求的数据会附在URL之后</li>
<li>POST是向服务器提交数据，POST把提交的数据包含在请求体中</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>链表知识总结</title>
    <url>/2021/03/10/%E9%93%BE%E8%A1%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表是一个线性的数据结构，存放链表的元素的地址是不连续的。链表的节点有两部分组成，分别是数据域和指针域。链表有单链表、双链表、单向循环链表、双向循环链表。<br><img src="/.io//linklist.png" alt="单链表"></p>
<h2 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h2><ul>
<li>动态分配内存</li>
<li>易插入、删除</li>
<li>无空间限制</li>
<li>内存利用率高</li>
</ul>
<h2 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h2><ul>
<li>指针域额外的空间开销</li>
<li>不能随意访问节点</li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>查找：O(n)<br>插入删除：O(1)</p>
]]></content>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ事务消息机制源码解析</title>
    <url>/2021/10/20/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="事务消息机制源码解析"><a href="#事务消息机制源码解析" class="headerlink" title="事务消息机制源码解析"></a>事务消息机制源码解析</h1><p>代码解析：</p>
<ol>
<li>发送事务消息入口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.transactionListener) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;TransactionListener is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.setTopic(NamespaceUtil.wrapNamespace(<span class="keyword">this</span>.getNamespace(), msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>TransactionListenner</code>为空则抛出异常，否则调用<code>defaultMQProducerImpl</code>类下的<code>sendMessageInTransaction</code>方法发送事务消息</p>
<ol>
<li><p>发送事务消息具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        TransactionListener transactionListener = getCheckListener();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;tranExecutor is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ignore DelayTimeLevel parameter</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() != <span class="number">0</span>) &#123;</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;send message Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">        Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        msg.putUserProperty(<span class="string">&quot;__transactionId__&quot;</span>, sendResult.getTransactionId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(transactionId)) &#123;</span><br><span class="line">                        msg.setTransactionId(transactionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                        localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Used new transaction API&quot;</span>);</span><br><span class="line">                        localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                        localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;executeLocalTransactionBranch return &#123;&#125;&quot;</span>, localTransactionState);</span><br><span class="line">                        log.info(msg.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;executeLocalTransactionBranch exception&quot;</span>, e);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                    localException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">            <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">            <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.endTransaction(msg, sendResult, localTransactionState, localException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;local transaction execute &quot;</span> + localTransactionState + <span class="string">&quot;, but end broker transaction failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">        transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">        transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">        transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">        transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">        <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在发送前先设置消息的PROPERTY_TRANSACTION_PREPARED属性为true，指定这是个半消息。同时设置消息的PROPERTY_PRODUCER_GROUP属性值为当前消息的生产者组是哪个。然后向Broker发消息。</p>
<ol>
<li>Broker接收生产者发送消息请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.processor;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;receive SendMessage request command, &#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimstamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;broker unable to service, until %s&quot;</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    String clusterName = <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerClusterName();</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)</span><br><span class="line">        &amp;&amp; !(msgInner.getReconsumeTimes() &gt; <span class="number">0</span> &amp;&amp; msgInner.getDelayTimeLevel() &gt; <span class="number">0</span>)) &#123; <span class="comment">//For client under version 4.6.1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                    + <span class="string">&quot;] sending transaction message is forbidden&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Broker</code>收到请求后，判断消息是不是半消息，如果是则调用<code>TransactionMessageService</code>类的<code>prepareMessage</code>方法，否则走普通消息的逻辑，即调用<code>MessageStore</code>的<code>putMessage</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">prepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalMessageBridge.putHalfMessage(messageInner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransactionalMessageBridge</code>是桥接类，作用主要是封装事务消息，然后用<code>MessageStore</code>的<code>putMessage</code>方法对半消息持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction.queue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">            String.valueOf(msgInner.getQueueId()));</span><br><span class="line">        msgInner.setSysFlag(</span><br><span class="line">            MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">        msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">        msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">        <span class="keyword">return</span> msgInner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在消息持久化之前，先将消息原本的<code>Topic</code>跟<code>QueueId</code>备份，然后将消息的主题设置成<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，将<code>QueueID</code>固定为0。注意此时的半消息对消费者是不可见的。半消息持久化完成后，会把消息发送的结果返回给生产者。</p>
<ol>
<li>收到消息发送成功响应，生产者执行本地事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    TransactionListener transactionListener = getCheckListener();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;tranExecutor is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ignore DelayTimeLevel parameter</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() != <span class="number">0</span>) &#123;</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;send message Exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">    Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    msg.putUserProperty(<span class="string">&quot;__transactionId__&quot;</span>, sendResult.getTransactionId());</span><br><span class="line">                &#125;</span><br><span class="line">                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(transactionId)) &#123;</span><br><span class="line">                    msg.setTransactionId(transactionId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;Used new transaction API&quot;</span>);</span><br><span class="line">                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                    localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;executeLocalTransactionBranch return &#123;&#125;&quot;</span>, localTransactionState);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;executeLocalTransactionBranch exception&quot;</span>, e);</span><br><span class="line">                log.info(msg.toString());</span><br><span class="line">                localException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endTransaction(msg, sendResult, localTransactionState, localException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;local transaction execute &quot;</span> + localTransactionState + <span class="string">&quot;, but end broker transaction failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">    transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">    transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">    transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">    transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">    <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息发送成功，生产者会调用<code>TransactionListener</code>的<code>executeLocalTransaction</code>方法执行本地事务。<code>localTransactionState</code>初始化状态为<code>UNKNOWN</code>，事务执行完成后会返回<code>COMMIT_MESSAGE, ROLLBACK_MESSAGE, UNKNOWN其一。如果发送失败，说明半消息没有持久化成功。此时设置</code>LocalTransactionState<code>为</code>ROLLBACK_MESSAGE<code>，但后续执行</code>RollBackMessage`的时候会提示找不到半消息。</p>
<ol>
<li>结束事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendResult sendResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Throwable localException)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MessageId id;</span><br><span class="line">    <span class="keyword">if</span> (sendResult.getOffsetMsgId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line">    String transactionId = sendResult.getTransactionId();</span><br><span class="line">    <span class="keyword">final</span> String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line">    EndTransactionRequestHeader requestHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">    requestHeader.setTransactionId(transactionId);</span><br><span class="line">    requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">    <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNKNOW:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doExecuteEndTransactionHook(msg, sendResult.getMsgId(), brokerAddr, localTransactionState, <span class="keyword">false</span>);</span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">    requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">    String remark = localException != <span class="keyword">null</span> ? (<span class="string">&quot;executeLocalTransactionBranch exception: &quot;</span> + localException.toString()) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>transactionID</code>、<code>CommitLogOffset</code>、<code>CommitOrRollBack</code>、<code>ProducerGroup</code>、<code>TranStateTableOffset</code>(<code>queueOffset</code>)这一系列参数写到请求的头部，然后发到Broker。</p>
<p>在Boker端会用<code>EndTransactionProcessor</code>去处理请求。</p>
<ol>
<li>EndTransactionProcessor</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.processor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> EndTransactionRequestHeader requestHeader =</span><br><span class="line">        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Transaction request:&#123;&#125;&quot;</span>, requestHeader);</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;Message store is slave mode, so end transaction is forbidden. &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getFromTransactionCheck()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, but it&#x27;s pending status.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, the producer commit the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, the producer rollback the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;The producer[&#123;&#125;] end transaction in sending message,  and it&#x27;s pending status.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;The producer[&#123;&#125;] end transaction in sending message, rollback the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OperationResult result = <span class="keyword">new</span> OperationResult();</span><br><span class="line">    <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCode(result.getResponseCode());</span><br><span class="line">    response.setRemark(result.getResponseRemark());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">checkPrepareMessage</span><span class="params">(MessageExt msgExt, EndTransactionRequestHeader requestHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String pgroupRead = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">            <span class="keyword">if</span> (!pgroupRead.equals(requestHeader.getProducerGroup())) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The producer group wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msgExt.getQueueOffset() != requestHeader.getTranStateTableOffset()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The transaction state table offset wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msgExt.getCommitLogOffset() != requestHeader.getCommitLogOffset()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The commit log offset wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">&quot;Find prepared transaction message failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">endMessageTransaction</span><span class="params">(MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">        MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line">        msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(msgExt.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());</span><br><span class="line">        msgInner.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line">        msgInner.setTransactionId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        TopicFilterType topicFilterType =</span><br><span class="line">            (msgInner.getSysFlag() &amp; MessageSysFlag.MULTI_TAGS_FLAG) == MessageSysFlag.MULTI_TAGS_FLAG ? TopicFilterType.MULTI_TAG</span><br><span class="line">                : TopicFilterType.SINGLE_TAG;</span><br><span class="line">        <span class="keyword">long</span> tagsCodeValue = MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());</span><br><span class="line">        msgInner.setTagsCode(tagsCodeValue);</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);</span><br><span class="line">        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID);</span><br><span class="line">        <span class="keyword">return</span> msgInner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Broker处理<code>endTransaction</code>请求时，先根据<code>MessageSysFlag</code>是<code>TRANSACTION_COMMIT_TYPE</code>还是<code>TRANSACTION_ROLLBACK_TYPE</code>。</p>
<ul>
<li>如果<code>MessageSysFlag</code>是<code>TRANSACTION_COMMIT_TYPE</code>, 则根据调用<code>TransactionMessageService</code>类的<code>commitMessage</code>方法。从语义上来说<code>commitMessage</code>是提交消息，其真实逻辑是根据返回的<code>result</code>的<code>commtLogOfset</code>从<code>commitLog</code>获取半消息。如果结果返回成功了，那么先调用<code>checkPreparedMessage</code>去检查半消息的合法性，半消息的<code>producrGroup</code>、<code>TranStateTableOffset</code>、<code>commitLogOffset</code>应该与请求头的参数相同，同时半消息不应该为空。如果半消息没问题，那么就调用<code>endMessageTransaction</code>方法。将半消息的<code>Topic</code>和<code>queueId</code>还原成在属性中备份的真实值。回到<code>processRequest</code>方法，因为在半消息持久化前，<code>MessageSysFlag</code>被设置成<code>TRANSACTION_NOT_TYPE</code>, 现在要commit消息，需要把<code>MessageSysFlag</code>改成<code>TRANSACTION_COMMIT_TYPE</code>，然后调用<code>sendFinalMessage</code>将还原后的消息持久化，调用<code>commitLogDispatcherBuildComsumer.dispatch</code>更新<code>topic</code>的<code>consumerQueue</code>，经过这些过程消息对消费者可见。<code>sendFinalMessage</code>执行完以后调用<code>TransactionService</code>的<code>deletePrepareMessage</code>将半消息删除。这个删除不是真正意义上的删除，而是构建一个<code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code>队列，<code>queueID</code>跟半消息的一样都是0，然后把消息插到队列里面去，消息内容是半消息的<code>queueOffset</code>，并将<code>TAGS</code>属性设为d(d也就是<code>TransactionalMessageUtil.REMOVETAG</code>)，标记这个消息的状态是已经<code>commit</code>或者<code>rollback</code>了。除此之外，还会创建一个哈希表<code>opQueueMap</code>, 让半消息的队列<code>messageQueue</code>映射到<code>opQueue</code>。</li>
<li>如果<code>MessageSysFlag</code>是<code>TRANSACTION_ROLLBACK_TYPE</code>。先调用<code>rollbackMessage</code>，根据返回的<code>result</code>获取半消息。检查半消息合法性后，删除半消息，逻辑跟前面的一样。</li>
</ul>
<ol>
<li>事务回查机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Start transaction check service thread!&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(checkInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;End transaction check service thread!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">        <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;Begin to check prepare message, begin time:&#123;&#125;&quot;</span>, begin);</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">        log.info(<span class="string">&quot;End to check prepare message, consumed time:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction.queue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> transactionTimeout, <span class="keyword">int</span> transactionCheckMax,</span></span></span><br><span class="line"><span class="function"><span class="params">    AbstractTransactionalMessageCheckListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">        Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">        <span class="keyword">if</span> (msgQueues == <span class="keyword">null</span> || msgQueues.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The queue of topic is empty :&quot;</span> + topic);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;Check topic=&#123;&#125;, queues=&#123;&#125;&quot;</span>, topic, msgQueues);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">            log.info(<span class="string">&quot;Before check, the queue=&#123;&#125; msgOffset=&#123;&#125; opOffset=&#123;&#125;&quot;</span>, messageQueue, halfOffset, opOffset);</span><br><span class="line">            <span class="keyword">if</span> (halfOffset &lt; <span class="number">0</span> || opOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;MessageQueue: &#123;&#125; illegal offset read: &#123;&#125;, op offset: &#123;&#125;,skip this queue&quot;</span>, messageQueue,</span><br><span class="line">                    halfOffset, opOffset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Long&gt; doneOpOffset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            HashMap&lt;Long, Long&gt; removeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The queue=&#123;&#125; check msgOffset=&#123;&#125; with opOffset=&#123;&#125; failed, pullResult is null&quot;</span>,</span><br><span class="line">                    messageQueue, halfOffset, opOffset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// single thread</span></span><br><span class="line">            <span class="keyword">int</span> getMessageNullCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> newOffset = halfOffset;</span><br><span class="line">            <span class="keyword">long</span> i = halfOffset;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Queue=&#123;&#125; process time reach max=&#123;&#125;&quot;</span>, messageQueue, MAX_PROCESS_TIME_LIMIT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (removeMap.containsKey(i)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;Half offset &#123;&#125; has been committed/rolled back&quot;</span>, i);</span><br><span class="line">                    Long removedOpOffset = removeMap.remove(i);</span><br><span class="line">                    doneOpOffset.add(removedOpOffset);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">                    MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                    <span class="keyword">if</span> (msgExt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getMessageNullCount++ &gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;No new msg, the miss offset=&#123;&#125; in=&#123;&#125;, continue check=&#123;&#125;, pull result=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                                messageQueue, getMessageNullCount, getResult.getPullResult());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;Illegal offset, the miss offset=&#123;&#125; in=&#123;&#125;, continue check=&#123;&#125;, pull result=&#123;&#125;&quot;</span>,</span><br><span class="line">                                i, messageQueue, getMessageNullCount, getResult.getPullResult());</span><br><span class="line">                            i = getResult.getPullResult().getNextBeginOffset();</span><br><span class="line">                            newOffset = i;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line">                        listener.resolveDiscardMsg(msgExt);</span><br><span class="line">                        newOffset = i + <span class="number">1</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (msgExt.getStoreTimestamp() &gt;= startTime) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Fresh stored. the miss offset=&#123;&#125;, check it later, store=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                            <span class="keyword">new</span> Date(msgExt.getStoreTimestamp()));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();</span><br><span class="line">                    <span class="keyword">long</span> checkImmunityTime = transactionTimeout;</span><br><span class="line">                    String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != checkImmunityTimeStr) &#123;</span><br><span class="line">                        checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);</span><br><span class="line">                        <span class="keyword">if</span> (valueOfCurrentMinusBorn &lt; checkImmunityTime) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) &#123;</span><br><span class="line">                                newOffset = i + <span class="number">1</span>;</span><br><span class="line">                                i++;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="number">0</span> &lt;= valueOfCurrentMinusBorn) &amp;&amp; (valueOfCurrentMinusBorn &lt; checkImmunityTime)) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;New arrived, the miss offset=&#123;&#125;, check it later checkImmunity=&#123;&#125;, born=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                                checkImmunityTime, <span class="keyword">new</span> Date(msgExt.getBornTimestamp()));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">                    <span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                        || (opMsg != <span class="keyword">null</span> &amp;&amp; (opMsg.get(opMsg.size() - <span class="number">1</span>).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                        || (valueOfCurrentMinusBorn &lt;= -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        listener.resolveHalfMsg(msgExt);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);</span><br><span class="line">                        log.debug(<span class="string">&quot;The miss offset:&#123;&#125; in messageQueue:&#123;&#125; need to get more opMsg, result is:&#123;&#125;&quot;</span>, i,</span><br><span class="line">                            messageQueue, pullResult);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newOffset = i + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newOffset != halfOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">            <span class="keyword">if</span> (newOpOffset != opOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Check error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">fillOpRemoveMap</span><span class="params">(HashMap&lt;Long, Long&gt; removeMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageQueue opQueue, <span class="keyword">long</span> pullOffsetOfOp, <span class="keyword">long</span> miniOffset, List&lt;Long&gt; doneOpOffset)</span> </span>&#123;</span><br><span class="line">        PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL</span><br><span class="line">            || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is illegal, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue,</span><br><span class="line">                pullResult);</span><br><span class="line">            transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is NO_NEW_MSG, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue,</span><br><span class="line">                pullResult);</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">        <span class="keyword">if</span> (opMsg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is empty, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue, pullResult);</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt opMessageExt : opMsg) &#123;</span><br><span class="line">            Long queueOffset = getLong(<span class="keyword">new</span> String(opMessageExt.getBody(), TransactionalMessageUtil.charset));</span><br><span class="line">            log.debug(<span class="string">&quot;Topic: &#123;&#125; tags: &#123;&#125;, OpOffset: &#123;&#125;, HalfOffset: &#123;&#125;&quot;</span>, opMessageExt.getTopic(),</span><br><span class="line">                opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);</span><br><span class="line">            <span class="keyword">if</span> (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queueOffset &lt; miniOffset) &#123;</span><br><span class="line">                    doneOpOffset.add(opMessageExt.getQueueOffset());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    removeMap.put(queueOffset, opMessageExt.getQueueOffset());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Found a illegal tag in opMessageExt= &#123;&#125; &quot;</span>, opMessageExt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;Remove map: &#123;&#125;&quot;</span>, removeMap);</span><br><span class="line">        log.debug(<span class="string">&quot;Done op list: &#123;&#125;&quot;</span>, doneOpOffset);</span><br><span class="line">        <span class="keyword">return</span> pullResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事务回查的核心功能是通过<code>TransactionMessageServieImpl</code>的<code>check</code>方法实现的。<code>TransactionMessageCheckServie</code>的<code>run</code>方法会启动一个线程，每隔<code>checkInterval</code>时间执行一次<code>onWaitEnd</code>方法调用<code>check</code>方法。在check方法中，首先根据半消息的<code>topic</code>拿到<code>msgQueue</code>，根据<code>msgQueue</code>拿到<code>opQueue</code>。在前面我们说过，半消息的<code>msgQueue</code>跟<code>opQueue</code>是一一对应的关系。如果<code>opQueueMap</code>为空，则创建一个空的<code>opQueue</code>，把两个队列的对应关系插入到<code>opQueueMap</code>里面。在用<code>halfOffset</code>和<code>opOffset</code>记录各自消费进度后，调用 <code>fillOpRemoveMap</code>去填充<code>removeMap</code>和<code>doneOpOffset</code>。在填充之前先用<code>pullOpMessage</code>从<code>transactionalMessageBridge</code>把从<code>pullOffsetOfOp</code>开始的32个message复制到现在的<code>opQueue</code>里。填充逻辑如下：</p>
<p><img src="/.io//image-20210831214240963.png" alt="image-20210831214240963"></p>
<p>对于半消息队列来说来说 <code>min offset</code>就是当前消费进度，<code>max offset</code>是最后一个消息的offset。对于op消息队列来说，<code>queue offset</code>当前op消息的内容，也就是在半消息中的offset。<code>max offset</code>最大是32，因为我们一次最多pull32个op消息到op消息队列。这个方法会遍历整个op消息队列，每次获取当前消息的内容<code>queue offset</code>然后跟<code>min offset</code>去比对，如果<code>queue offset &lt; min offset</code>说明这个消息已经是已经被处理过了，不用再管。其余的按照key为半消息队列offset， value为op消息队列offset插入removeMap，说明key对应的半消息不需要回查。</p>
<p>在填充完<code>removeMap</code>后会进入一个循环 ，从<code>halfOffset</code>开始去遍历半消息，<code>removeMap</code>的key包含这个offset，说明这个offset对应的半消息已经被commit或者rollback了，不需要回查，执行下一个offset+1对应 半消息的检查。如果是不在<code>removeMap</code>里面，就用<code>needDiscard</code>去判断这个消息有没有超过最大回查次数15次，如果超过15次了那就不查了。同时要判断这个半消息存盘后有没有超过72个小时，因为超过72小时这个半消息会被丢弃。接下来有一个<code>checkImmunityTimeStr</code>，这个是回查免疫时间，就是消息存盘后这个回查免疫时间内是不进行回查的。如果在这个时间内，而且而且是首次回查，就不进行回查。如果是生产者没有设置首次回查免疫时间，如果在免疫时间内就跳过当前半消息以及后续所有的的半消息的回查，因为同一个consumer中的消息是有顺序的。如果前面条件都满足，就调用<code>putBackHalfMsgQueue</code>再次存盘。因为这次回查是否能够确定状态是不知道的，为了下一次回查，将这个半消息再次存盘。然后调用<code>resolveHalfMsg</code>进行回查逻辑。每次回查结束都更新半消息队列和op消息队列。这个while循环是有时间限制的，如果超过时间限制则会跳出循环。</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解消息队列</title>
    <url>/2021/10/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="彻底理解Message-Queue-MQ"><a href="#彻底理解Message-Queue-MQ" class="headerlink" title="彻底理解Message Queue(MQ)"></a>彻底理解Message Queue(MQ)</h1><h2 id="一、什么是MQ"><a href="#一、什么是MQ" class="headerlink" title="一、什么是MQ"></a>一、什么是MQ</h2><p>MQ是消息在传输过程中保存消息的容器，本质上是个队列。生产者发送消息到MQ中排队，然后由消费者接收消息并进行处理。</p>
<h3 id="1、原始模型"><a href="#1、原始模型" class="headerlink" title="1、原始模型"></a>1、原始模型</h3><p><img src="/.io//\image-20210828001029404.png" alt="image-20210828001029404"></p>
<p>原始模型允许多个生产者把消息存到队列里，但是一个消息只能被一个消费者接受，因为消息出队后就没有了。因此原始模型不适于生产者将消息分发给各个消费者。</p>
<h3 id="2、发布-订阅模型"><a href="#2、发布-订阅模型" class="headerlink" title="2、发布-订阅模型"></a>2、发布-订阅模型</h3><p><img src="/.io//\image-20210828002901708.png" alt="image-20210828002901708"></p>
<p>在发布-订阅模型中，原来的队列变得跟主题一样，只有消费者订阅了主题，才能接收到这个主题的全量信息。</p>
<h2 id="二、MQ的作用"><a href="#二、MQ的作用" class="headerlink" title="二、MQ的作用"></a>二、MQ的作用</h2><h3 id="1、异步"><a href="#1、异步" class="headerlink" title="1、异步"></a>1、异步</h3><p><img src="/.io//\image-20210828154746882.png" alt="image-20210828154746882"></p>
<p>对于一些复杂的业务系统，一次请求可能会同步调用多个系统的接口。每调用一个系统接口都要等待结果返回才继续调用下一个系统接口。直到所有的结果都返回了，整个流程才走完，这样耗时是非常多的。</p>
<p><img src="/.io//\image-20210828160441522.png" alt="image-20210828160441522"></p>
<p>引入了MQ之后，生产者发送消息后立即返回，可以继续做别的事情，无需等待消费者的返回，消费者会独立完成所有的业务逻辑(这些操作就是异步调用消费者接口)。这样做提高了系统的响应速度和吞吐量。</p>
<h3 id="2、解耦"><a href="#2、解耦" class="headerlink" title="2、解耦"></a>2、解耦</h3><p>生产者只需要将消息写进主题(队列)中，对消费者是什么样的，是不是需要这个消息根本不关心。消费者如果需要这个消息，只需要订阅主题(调用读消息接口)，不需要对生产者做任何改变。服务之间进行解耦，可以减少服务之间的影响，提高了系统的稳定性和可扩展性。</p>
<h3 id="3、削峰"><a href="#3、削峰" class="headerlink" title="3、削峰"></a>3、削峰</h3><p>机器同时处理请求的能力是有限的，在高并发的情况下，把消息写到队列里面缓存，消费者根据自己的处理能力去消息队列里拿数据。MQ可以以稳定的系统资源应对突发的流量冲击。</p>
<h2 id="三、MQ的缺点"><a href="#三、MQ的缺点" class="headerlink" title="三、MQ的缺点"></a>三、MQ的缺点</h2><h3 id="1、系统可用性降低"><a href="#1、系统可用性降低" class="headerlink" title="1、系统可用性降低"></a>1、系统可用性降低</h3><p>一旦MQ宕机，整个服务都会受到影响。</p>
<h3 id="2、系统复杂度提高"><a href="#2、系统复杂度提高" class="headerlink" title="2、系统复杂度提高"></a>2、系统复杂度提高</h3><p>引入MQ后数据链路变得很复杂，不容易排查问题。</p>
<h3 id="3、数据一致性问题"><a href="#3、数据一致性问题" class="headerlink" title="3、数据一致性问题"></a>3、数据一致性问题</h3><p>如果一个系统发消息需要多个系统协同处理，其中一些系统处理成功，一些处理失败，就会造成数据一致性问题。</p>
<h3 id="4、消息丢失问题"><a href="#4、消息丢失问题" class="headerlink" title="4、消息丢失问题"></a>4、消息丢失问题</h3><p>生产者、MQ服务器、消费者这三者在工作过程中都有可能丢失消息，结果会导致消息无法被正确处理，最终导致数据不一致问题。</p>
<h3 id="5、重复消费问题"><a href="#5、重复消费问题" class="headerlink" title="5、重复消费问题"></a>5、重复消费问题</h3><p>由于网络的不稳定性，消息重复发送，消息重复消费不可避免地发生。重复消费如果不加处理，会产生重复数据或者数据异常，对业务造成严重影响。</p>
<h3 id="6、消息顺序问题"><a href="#6、消息顺序问题" class="headerlink" title="6、消息顺序问题"></a>6、消息顺序问题</h3><p>如果消息队列里的数据如果是对同一个数据库进行操作，而这些操作具有先后关系，如果消费的顺序不对，就会造成数据异常问题。</p>
<h2 id="四、MQ的选型"><a href="#四、MQ的选型" class="headerlink" title="四、MQ的选型"></a>四、MQ的选型</h2><h3 id="1、Kafka"><a href="#1、Kafka" class="headerlink" title="1、Kafka"></a>1、Kafka</h3><p>吞吐量大(10万级别)，延迟低(ms级以内)，基于分布式架构实现高可用，消息可靠性低，容易丢数据。适合做日志采集和大数据分析。</p>
<h3 id="2、RabbitMQ"><a href="#2、RabbitMQ" class="headerlink" title="2、RabbitMQ"></a>2、RabbitMQ</h3><p>吞吐量一般(万级别)，延迟非常低(us级)，基于主从架构实现高可用。erlang语言难度高 ，不好定制MQ。适合小规模场景。</p>
<h3 id="3、RocketMQ"><a href="#3、RocketMQ" class="headerlink" title="3、RocketMQ"></a>3、RocketMQ</h3><p>吞吐量大(10万级别)，延迟低(ms级)， 基于分布式架构实现高可用，但只支持Java。几乎适合全场景。</p>
<h2 id="五、MQ如何保持消息不丢失"><a href="#五、MQ如何保持消息不丢失" class="headerlink" title="五、MQ如何保持消息不丢失"></a>五、MQ如何保持消息不丢失</h2><h3 id="1、消息丢失的环节"><a href="#1、消息丢失的环节" class="headerlink" title="1、消息丢失的环节"></a>1、消息丢失的环节</h3><h4 id="（1）生产者发送消息丢失"><a href="#（1）生产者发送消息丢失" class="headerlink" title="（1）生产者发送消息丢失"></a>（1）生产者发送消息丢失</h4><h4 id="（2）MQ服务器主从同步不丢失"><a href="#（2）MQ服务器主从同步不丢失" class="headerlink" title="（2）MQ服务器主从同步不丢失"></a>（2）MQ服务器主从同步不丢失</h4><h4 id="（3）MQ消息存盘不丢失"><a href="#（3）MQ消息存盘不丢失" class="headerlink" title="（3）MQ消息存盘不丢失"></a>（3）MQ消息存盘不丢失</h4><h4 id="（4）消费者消费消息不丢失"><a href="#（4）消费者消费消息不丢失" class="headerlink" title="（4）消费者消费消息不丢失"></a>（4）消费者消费消息不丢失</h4><h3 id="2、如何防止生产者发送消息不丢失"><a href="#2、如何防止生产者发送消息不丢失" class="headerlink" title="2、如何防止生产者发送消息不丢失"></a>2、如何防止生产者发送消息不丢失</h3><h4 id="（1）Kafka"><a href="#（1）Kafka" class="headerlink" title="（1）Kafka"></a>（1）Kafka</h4><p><img src="/.io//\image-20210828184039913.png" alt="image-20210828184039913"></p>
<p>生产者发送消息到MQ，如果MQ正常收到消息，则会返回一个请求去调用生产者的一个回调函数，让生产者知道MQ已经正确地收到了消息。生产者这里会启动一个定时任务，如果生产者长时间没有调用这个回调函数，生产者就会重新发送消息。</p>
<h4 id="（2）RocketMQ"><a href="#（2）RocketMQ" class="headerlink" title="（2）RocketMQ"></a>（2）RocketMQ</h4><p>RocketMQ在Kafka的基础上加上了事务消息的机制。以下是事务消息的定义。</p>
<blockquote>
<p>It can be thought of as a two-phase commit message implementation to ensure eventual consistency in distributed system. Transactional message ensures that the execution of local transaction and the sending of message can be performed atomically.</p>
</blockquote>
<p><img src="/.io//\image-20210828190735880.png" alt="image-20210828190735880"></p>
<p>事务消息用两阶段提交去保证分布式系统的最终一致性，它保证了本地事务和发消息这两件事情是原子性的。</p>
<p>以下为RocketMQ事务消息机制流程:</p>
<p><img src="/.io//\image-20210829123454095.png" alt="image-20210829123454095"></p>
<h3 id="（3）RabbitMQ"><a href="#（3）RabbitMQ" class="headerlink" title="（3）RabbitMQ"></a>（3）RabbitMQ</h3><p>RabbitMQ采用的是发送消息+回调+手动事务的机制。在RabbitMQ中提供了一组api，让使用者自己组织事务逻辑。但是这种方式会对channel产生阻塞，造成吞吐量下降。在3.0+版本提出了Publisher Confirm机制，跟RocketMQ的二次提交处理机制类似。</p>
<h2 id="3、如何防止MQ消息同步不丢失"><a href="#3、如何防止MQ消息同步不丢失" class="headerlink" title="3、如何防止MQ消息同步不丢失"></a>3、如何防止MQ消息同步不丢失</h2><h3 id="（1）RocketMQ"><a href="#（1）RocketMQ" class="headerlink" title="（1）RocketMQ"></a>（1）RocketMQ</h3><p>在rocket集群中，有同步同步，异步同步两种同步方式。</p>
<ul>
<li><p>同步同步</p>
<p><img src="/.io//\image-20210831225537359.png" alt="image-20210831225537359"></p>
</li>
</ul>
]]></content>
  </entry>
</search>

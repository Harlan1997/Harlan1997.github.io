<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++基础</title>
    <url>/2021/03/20/C-C++%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++11 新特性"></a>C++11 新特性</h2><ul>
<li>nullptr</li>
<li>auto</li>
<li>右值引用 移动语义</li>
<li>正则表达式</li>
</ul>
<h1 id="struct-跟-class的区别"><a href="#struct-跟-class的区别" class="headerlink" title="struct 跟 class的区别"></a>struct 跟 class的区别</h1><p>struct是数据结构实现体，而class是对象实现体<br>最明显的一个区别是访问控制，struct是public的，class是private的</p>
<h2 id="变量和对象"><a href="#变量和对象" class="headerlink" title="变量和对象"></a>变量和对象</h2><ul>
<li>变量：内存在代码中可视化的一个符号</li>
<li>对象：对象是指一块能存储数据并具有某种类型的内存空间</li>
</ul>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><ul>
<li>左值：表示可以取地址的，有名字的，非临时的对象，如非匿名对象，函数返回的引用，const对象等。</li>
<li>右值：不能取地址的，没有名字的，临时的表达式，如立即数，函数返回值等。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>定义：是给变量起的别名</li>
<li>用法：<code>Type &amp;name = var</code>。声明引用时，必须用其它的变量进行初始化(说明引用是个常量)。引用作为函数的参数声明时不进行初始化。</li>
<li>为什么需要引用？<br>引用作为其它变量的别名而存在，在一些场合可以替代指针。相对于指针来说引用具有更好的可读性和实用性。</li>
<li>引用的本质：指针常量</li>
</ul>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。相关代码执行完匿名对象就消失了。</p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>就是对一个左值进行引用的类型。左值引用通常不能绑定右值。左值引用它可以接受非常量左值、常量左数值、右值对其进行初始化。左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改据，因为其被const修饰成常量引用了。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用是C++ 11新增的特性，右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。右值引用跟常引用的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。右值引用通常不能绑定左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p>
<ul>
<li>为什么需要右值引用？<br>右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，再进行使用，这是很浪费时间的。</li>
<li>转移语义：将右值引用绑定到左值，避免多余的内存拷贝。std::move()</li>
<li>完美转发：只有在需要的时候，才调用复制构造函数，左值被转发为左值，右值被转发为右值。std::forward()</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>储存地址的变量</p>
<ul>
<li>指针跟引用的区别<br>引用是指针常量，地址不能改变。指针没有这个限制。</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是指向动态分配（堆）对象指针，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数。每次使用它，内部的引用计数加1，每次析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。智能指针包括：shared_ptr， unique_ptr， weak_ptr。<br>share_ptr：多个指针指向同一个对象，当最后一个指针离开作用域时，内存才会释放。<br>unique_ptr：资源只能被一个unique_ptr占有，当unique_ptr离开作用域，内存会被释放。如果资源被其它资源重写了，之前拥有的资源也会被释放。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物抽象成的类。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>消息以多种形态显示的能力，多态以封装和继承为基础。<br>C++多态实现：</p>
<ul>
<li>重载多态</li>
<li>子类型多态</li>
<li>参数多态</li>
<li>强制多态</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在某基类中声明为virtual，并在一个或多个派生类中被重新定义的成员函数。在基类中可以实现，可以不实现，它的作用是让这个函数能在子类中被覆盖，子类可以不重写。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>只是一个接口，基类中不能有实现，子类要实现才可以实例化。</p>
<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>如果编译器发现基类中有虚函数，会自动为每个含有虚函数的类生成一份虚函数表，该表是一个一维数组，保存了虚函数的入口地址。编译器会在每个对象的前4个字节保存一个虚表指针，指向对象所属的虚表。在对象实例化时会</p>
<h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝 浅拷贝"></a>深拷贝 浅拷贝</h2><p>浅拷贝是对指针的拷贝<br>深拷贝是对指针和指针所指向内容</p>
<h2 id="内存中堆栈的区别"><a href="#内存中堆栈的区别" class="headerlink" title="内存中堆栈的区别"></a>内存中堆栈的区别</h2><p>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文<br>堆：般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>basic quantum theory</title>
    <url>/2021/03/06/basic-quantum-theory/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当年在上大学物理的时候的课程项目要求每个人都做一下物理学前沿知识的报告，我的小组选了Quantum Computation这一个课题。在这个报告中我主要负责Quantum Computation涉及到的一些基本的Quantum Mechanics的知识，其中的大部分内容总结自Dirac的《The Principles of Quantum Mechanics》和量子计算的bible《Quantum Computation and Quantum Information》。这是我这篇报告的由来。<br><span id="more"></span></p>
<h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Quantum mechanics is the science of the very small. It explains the behavior of matter and its interactions with energy on the scale of atoms and subatomic particles. By contrast, classical physics only explains matter and energy on a scale familiar to human experience, including the behavior of astronomical bodies such as the Moon. Classical physics is still used in much of modern science and technology. However, towards the end of the 19th century, scientists discovered phenomena in both the large (macro) and the small (micro) worlds that classical physics could not explain.The desire to resolve inconsistencies between observed phenomena and classical theory led to two major revolutions in physics that created a shift in the original scientific paradigm: the theory of relativity and the development of quantum mechanics</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>As in classical mechanics, the state of a particle at any given time is specified by two variables position an momentum. If we know these quantities, we can get all the information of the system we want to measure. For example, energy is just some function of position and momentum. We can calculate it if we know the position and momentum. However, this is impossible in quantum mechanics. In atom scale, according to the uncertainty principle, we can’t specify the position and momentum at the same time. How can can we specify the state of a system? By the Copenhagen interpretation, a state of a particle is completely specified by a complex wave function $\ket{\psi}$ and it is described to be a probability amplitude, whose square modulus gives the probability density of finding the particle at point x at time t.</p>
<p>A mixture of quantum states is also a quantum state. Quantum states that cannot be writtten as a mixtrue of other states are called pure quantum states, all other states are called mixed quantum state.</p>
<p>Mathematically, a pure quantum state can be represented by a ray in a Hilbert space over the complex numbers. The ray is a set of nonzero vecctor differing by just a complex factor; any of them can be chosen as a state vector to represent the ray and thus the state. A unit vector is usually picked, but its phase factor can be chosen freely anyway. Nevertheless, such factors are important when state vectors are added together to form a superposition.</p>
<p>A mixed quantum state corresponds to a probabilistic mixture of pure state; however, different distribution of pure states can generate equavalent mixed states. Mixed states are describe by density matrices. A pure state can also be recast as a density matrix; in this way, pure statee can be represented as a subset of more general mixed states.</p>
<h3 id="Bracket-Notaion"><a href="#Bracket-Notaion" class="headerlink" title="Bracket Notaion"></a>Bracket Notaion</h3><p>The absence of a state is represented by the null vector $\ket{0}$ in ket space. The null vector has the fairly obvious property that. $\ket{A}+\ket{0}=\ket{A}$</p>
<p>Now we know that any plane polarized state of a photon can be represented as a linear superposition of two orthogonal polarization states in wichi the weights are real numbers. Suppose we want to construct a circular polarized photon state. Remind that a circularly polarized wave is a superposition of two waves of equal amplitude, plane polarized in the X-direction and a photon polarized in the y-direction, with equal weights given to the two states. To descrive a circularly polarized photon, we can use complex numbers to simultaneously represent the weighting and relative phase phase in a linear superposition. Suppose state B represents the photon polarizing in the x-direction, state C represents the photon polarizing in the y-direction, written as $\ket{B}+i\ket{C}$. Then we can conclude: a general elliptically polarized photon is represeted by $c_1\ket{B}+c_2\ket{C}$ where $c_1 and c_2$ are complex numbers. It implies that a ket space must be a complex vector space.</p>
<p>Any ket vector that is expressible linearly in terms of cortain orthers is said to be dependent on them. Likewise, a set of ket vecotrs are termed independent if none of them are expressible linearly interms of them. The dimension of a ket space is equivalent to the number of independent ket vectors it contains. If there are N independent states then the possible states of the system are represtned as an N-dimensional ket space. Remind some microscopic sysyems have an infinite number of independent states(e.g.,a particle in an infinite, one dimensional, potential well). The possible states are represented as a ket in a ket space whose dimention are infinite.<br>In conclusion, the state of a general microspopic system can be represented as a complex vector space of infinite dimension. Such a space is called  Hilbert space.</p>
<p>Imagine a general functional, label F, acting on a general ket vector, lavel A, and spitting out a general complex number $\phi_A$. This process is represented by writing $\bra{F}(\ket{A})=\phi_A$. Suppose there is a linear functional functionals, satisfies $\bra{F}(\ket{A}+\ket{B})=\braket{F|A}+\braket{F|B}$ where $\ket{A}$ and $\ket{B}$ are any two kets in a given Hilbert space. In a Hilbert space, a general ket vector can be written as $\sum_{i=1}^Na_i\ket{i}$ where $\ket{i}$(i=1,2,3,…,n) represents n independent ket vector in this space, $a_i$ is an arbitrary complex number. Then the functional $\braket{F|A}=\sum_{i=1}^Nf_ia_i$ where $f_i$ are a set of complex numbers relating to the functional. Define n basis of functionals $\bra{i}$ (i=i,2,3,…,n) which satisfy $\braket{i|j}=\delta_{ij}$.Then we get $\bra{F}=\sum_{i=1}^Nf_i\bra{i}$. This implies that the set of all possible linear functionals acting on a n-dimentional ket space is itself an n-dimensional vector space. This type of vector space is called bra space. The vector in this space are called bra vectors. Bra space is an example of what mathematicians call a dual space.  It is dual to the original ket space.</p>
<p>For a general ket vector $A$, the corresponding bra is written as <script type="math/tex">\bra{A}=\sum_{i=1}^Na_i^*\bra{i}</script> where $a_i^*$ are the complex conjugate of $a_i$. Given a ket $\ket{A}$, which is not the null ket, we can define a normalized $\ket{\tilde{A}}$ where $\braket{\tilde{A}|\tilde{A}}=1$. Since $\ket{A}$ and $c\ket{A}$ represent the same physical state (we can not form a new state by superposing a state with itself), it makes sense to require that all kets corresponding to physical states have unit norms.</p>
<h3 id="Wave-Function"><a href="#Wave-Function" class="headerlink" title="Wave Function"></a>Wave Function</h3><p>A wave function in quantum physics is a mathematical description of the quantum state of an isolated quantum system. The wave function is a complex-valued probability amplitude, whose square modulus gives the probability density at a point x. Since we have wave function is complex value, only its relative phase and relative magnitude can be measured. We have to apply quatum operator, whose eigenvalues corresponding to sets of possible results of measurements, to the wave function $\psi$ an calculate the statistical distribution for measurable quantities. The most common symbols for a wave function are the Greek letter $\psi$</p>
<p>Given a basis kets $\ket{k_i}$ of Hilbert space, any ket $\ket{\psi}$ can be written as $\ket{\psi}=\sum_{i=1}^nc_i\ket{k_i}$ where $c_i$ are complex numbers. If the basis is chosen to be orthonormal, then $c_i=\braket{k_i|\psi}$. If $\ket{k_i}$ is eigenstates of an observable with eigenvalue $c_i$, and the observable is measured on the normalized state$\ket{\psi}$, then the probability that the result of the measurement is $k_i$ is $|c_i|^2$.</p>
<p>A particular importan example is the position basis, which is the basis consisting of eigenstates $\ket{\textbf{r}}$ with eigenvalue $\textbf{r}$ of the observable which corresponds to measure position. If these eigenstates are nondegenerate, then the ket $\ket{\psi}$ is associate with a complex-value wave function of there-dimentional space $\psi(\textbf{r})=\braket{\textbf{r}|\psi}$. Simlilarly, the probability density of the particle being found at position $\textbf{r}$ is $|\psi(\textbf{r})|^2$ and the normalized state have $\int d^3\textbf{r}|\psi(\textbf{r})|^2=1$.</p>
<h3 id="Superposition"><a href="#Superposition" class="headerlink" title="Superposition"></a>Superposition</h3><p>If we take any atomic system, there will be many possible motions of the particles consistent with the law of forcee. Each such motion is called a state of the system. A state of a system may be defined as an undistrubuted motion that is whithout mutual interference or contradiction. The general principle of superposition of quantum mechanics applied to the states of any one dynamical system. It requires us to assume that between these states there exist peculiar repationships wuch that whenever the system is definitely in one state we can consider as being partly in each of two or more other states.</p>
<p>When a state is formed by the superposition of other states. As we obserbe, the result shows that the system sometimes in one state, sometimes in another state. The result can’t be determined though the obseervation made. It is the law of nature. The principle was described by Paul Dirac as follows:</p>
<blockquote>
<p>The non-classical nature of the superposition process is brought out clearly if we consider the superpostion of two states, A and B, such that there exists an observation which, when made on the system in states A, is certain to lead to one particular result a.And when made on the system in state B is certain to lead to some different result b. What will be the result of the observation when made on the system in the superposed state? The answer is that  the result will be somtimes a and sometimes b, according to a probability law depending on the relative weights of A and B in the superposition process. It will never be different from both a and b. The intermediate character of the state formed by superposition thus expresses itself throught  the probability of a particular result for an observation being intermediate between the corresponding probabilities for the original states, not throught the result itself being intemediate between the corresponding result for the original states.</p>
</blockquote>
<p>As an example, suppose there are two eigenstates $\ket{\psi_i}$ and $\ket{\psi_2}$, the superposition of them is their linear combination $c_1\ket{\psi_1}+c_2\ket{\psi_2}$. If we make an observation on the system. The wave function of the system will collapse to an eigenstate of the observable randomly. The probability ralating to the eigenstate $\ket{\psi_1}$ is $|c_1|^2$, the probability relating to eigensteate $c_2$ is $|c_2|^2$. </p>
<h3 id="Entanglement"><a href="#Entanglement" class="headerlink" title="Entanglement"></a>Entanglement</h3><p>By definition, quantum entanglement is a physical phenomenon which occurs when pairs or groups of particles are generated or interact in ways such that the quantum state of each that the quantum state of each particle cannot be described independently of the state of the others, even when the particles are separated by large distance.</p>
<p>So far, we have assumed that the system is made of a single component. Suppose a system is made of two component: one in a Hilbert space $H_1$ and another component in another Hilber space $H_2$. Then the system as a whole live in a Hilbert space $H=H_1\otimes H_2$. The general vector in this space is written as $\ket{\psi}=\sum_{i,j}c_{ij}\ket{e_1,i}\otimes\ket{e_2,j}$ where $\ket{e_a,i}$(a=1,2) is an orthonormal basis in $H_a$ and $\sum_{i,}|c_{ij}|^2=1$. A state $\ket{\psi}\in H$ written as a tensor product of two vector $\ket{\psi}=\ket{\psi_1}\otimes\ket{\psi_2}$ is called a tensor product state or a separable state. Non-separable states are called entangle state.</p>
<p>The set of separate states have dimension $dimH_1+dimH_2$. The total space $H$ has dimension $dimH_1dimH_2$.When the dimension of original Hilbert space is large,we have $dimH_1dimH_2$&gt;$dimH_1+dimH_2$. Then most states in the total space are entangled.</p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>quantum mechanics</tag>
        <tag>quantum computation</tag>
      </tags>
  </entry>
  <entry>
    <title>“联邦学习下的安全矩阵分解论文笔记”</title>
    <url>/2021/03/07/%E2%80%9C%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E2%80%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大数据时代，数据是人工只能产业化中不可缺少的基石。随着数据的隐私和安全被越来越重视，很多国家都开始出台有关保护数据隐私的政策，这使得非常依赖数据的人工智能产业陷入了困境。如何在满足数据隐私、安全和监管要求的前提下，让人工智能系统能够更加高效、准确的共同使用各自的数据，是当前人工智能发展的一个重要课题。2016年，Google提出了Federated Learning(FL)的概念，旨在训练一个基于分布在各个用户的移动设备上个人信息的中心化模型。目前在FL上的工作已经有很多。本文将对FL在Matrix Factorization(MF)应用，Secure Federated Matrix Factorization进行介绍。</p>
<h2 id="隐私信息泄露"><a href="#隐私信息泄露" class="headerlink" title="隐私信息泄露"></a>隐私信息泄露</h2><p>对于推荐算法来说，拿MF来说，有两类数据是被暴露出来的，一类是用户的raw </p>
]]></content>
      <tags>
        <tag>Fedrated Learning, Matrix Factorization, Recommending System</tag>
      </tags>
  </entry>
  <entry>
    <title>后端知识点总结</title>
    <url>/2021/03/26/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ul>
<li>线性表</li>
<li>栈</li>
<li>队列</li>
<li>数组</li>
</ul>
<h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><ul>
<li>单链表(链表和数组的区别)</li>
<li>双向链表</li>
<li>循环链表(约瑟夫环)</li>
<li>双向循环链表</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>二叉树</li>
<li>二叉搜索树</li>
<li>AVL树</li>
<li>红黑树</li>
<li>B树</li>
<li>B+树</li>
</ul>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>邻接表</li>
<li>临界矩阵</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>堆排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li>顺序查找</li>
<li>二分查找</li>
<li>哈希查找</li>
<li>二叉树查找</li>
<li>红黑树查找</li>
<li>B/B+树查找</li>
</ul>
<h3 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h3><ul>
<li>BFS</li>
<li>DFS</li>
</ul>
<h3 id="其它算法"><a href="#其它算法" class="headerlink" title="其它算法"></a>其它算法</h3><ul>
<li>分治法</li>
<li>动态规划</li>
<li>贪心</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="什么是同步-什么是异步"><a href="#什么是同步-什么是异步" class="headerlink" title="什么是同步 什么是异步"></a>什么是同步 什么是异步</h2><p>同步：必须等对方回应我，才开始做下一件事情<br>异步：不必等对方回应我，我继续做我的事情</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>资源分配的独立单位</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ul>
<li>管道</li>
<li>信号量</li>
<li>信号</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>资源调度的独立单位</p>
<h2 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h2><ul>
<li>锁 互斥锁 读写锁 自旋锁 条件变量</li>
<li>信号量</li>
<li>信号</li>
<li>屏障</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>有一个线程在对内存进行操作的时候，其他线程都不可以对这个内存地址进行操作</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>实现协作式多任务，可以在程序执行内部中断，转而执行其它协程</p>
<ul>
<li>跟线程的区别：效率比线程高，因为切换不需要开销。不需要线程的锁机制。</li>
</ul>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>计算机执行多个进程</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>先来先去</li>
<li>短作业优先调度</li>
<li>轮转法</li>
<li>多级反馈队列</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个进程中同时有多个线程正在执行</p>
<h2 id="多线程跟多进程的区别"><a href="#多线程跟多进程的区别" class="headerlink" title="多线程跟多进程的区别"></a>多线程跟多进程的区别</h2><ul>
<li>多进程：编程、调试简单，可靠性高，但创建、销毁、切换速度慢、内存资源占用高。</li>
<li>多线程：编程、调试复杂，可靠性差，但创建、销毁、切换速度快、内存资源占用低。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>多个进程互相等待对方资源，循环等待。</li>
</ul>
<h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul>
<li>资源互斥</li>
<li>资源不可剥夺</li>
<li>占有资源后还继续请求新的资源</li>
<li>环路等待</li>
</ul>
<h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>破坏四个必要条件之一即可。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>短连接：连接-&gt;传输数据-&gt;关闭连接<br>长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ……….-&gt;直到一方关闭连接，多是客户端关闭连接。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。"><a href="#定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。" class="headerlink" title="定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。"></a>定义：连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</h3><h3 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h3><ul>
<li>无连接</li>
<li>尽力可靠</li>
<li>没拥塞控制</li>
<li>首部开销小</li>
<li>支持一对多、多对多、多对一、一对一通信                            </li>
</ul>
<h2 id="滑窗协议"><a href="#滑窗协议" class="headerlink" title="滑窗协议"></a>滑窗协议</h2><p>发送端窗口里左边是已发送但未确认，右边是未发送。发送端一次性发多个分组，接收方只能对按序到达的分组中序列号最高的分组给出确认。如果没有发生丢失或超时，接收方不再保留按序保留的分组，接收端窗口向前移动，同时向发送端发送确认。发送端收到确认之后窗口也向前移动。如果接收端没有收到按序到达的分组，接收端会对按序到达序列号最高的分组给出确认。发送端收到确认移动窗口后，在一段时间后还没有收到接收端的确认，发送端就会重传这部分数据，直到收到确认为止。</p>
<h2 id="GET-POST登陆上的区别"><a href="#GET-POST登陆上的区别" class="headerlink" title="GET POST登陆上的区别"></a>GET POST登陆上的区别</h2><ul>
<li>GET是从服务器上获取数据，GET请求的数据会附在URL之后</li>
<li>POST是向服务器提交数据，POST把提交的数据包含在请求体中</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>用Github pages和Hexo搭建自己的个人博客</title>
    <url>/2021/03/06/%E7%94%A8Github-pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pages.github.com/">Github Pages</a>是一个静态站点托管服务, 用户可以可以从Github直接获取HTML, CSS, Java Script文件, 用户可以用这些文件来发布网页。<br><a href="https://hexo.io/">Hexo.io</a>是一个基于Node.js的快速、简单、功能强大的博客框架。<br>本门将介绍如何使用Hexo + Github Pages搭建个人博客。<br><span id="more"></span></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载和安装Node.js和Git</p>
<ul>
<li>Node.js下载地址: <a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git下载地址: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<h2 id="Git连接Github"><a href="#Git连接Github" class="headerlink" title="Git连接Github"></a>Git连接Github</h2><p>打开Git Bash</p>
<ul>
<li>设置用户名和邮箱<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub邮箱&quot;</code></li>
<li>生成SSH密钥<br><code>ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot;</code></li>
<li>为Github账户添加SSH密钥<br>公钥默认保存在 <code>C:\Users\用户名\.ssh</code>目录中, 用记事本打开 id_rsa.pub，复制内容。<br>点开github页面右上角头像,在Settings-&gt;SSH and GPG keys中点击New SSH key, 随便取个标题, 将复制的公钥粘贴进去, 点击Add SSH key </li>
<li>验证连接<br>打开Git Bash, 输入<br><code>ssh -T git@github.com</code><br>如果显示”You’ve successfully authenticated, but…”则连接成功</li>
</ul>
<h2 id="创建Github-Pages-Repository"><a href="#创建Github-Pages-Repository" class="headerlink" title="创建Github Pages Repository"></a>创建Github Pages Repository</h2><ul>
<li>点开github页面右上角旁边的加号，选择New repository</li>
<li>Repository name填上 <code>用户名.github.io</code></li>
<li>勾选 Add a README file</li>
<li>点击 Create repository</li>
</ul>
<h2 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h2><ul>
<li>找一个地方新建文件夹, 命名为hexo用来存放Hexo程序</li>
<li>打开Git CMD 进入到hexo的文件夹(注意这里不是Git Bash, 如果用Git Bash可能会碰到奇奇怪怪的问题)</li>
<li>npm安装hexo<br><code>npm install -g hexo-cli</code></li>
<li>hexo文件下载<br><code>hexo init</code></li>
<li>生成静态文件<br><code>hexo g</code></li>
<li>部署到本地服务器4000端口<br><code>hexo s</code><br>如果访问<code>http://localhost:4000</code>看到Hexo默认页面的Hello World则本地博客安装成功</li>
</ul>
<h2 id="部署Hexo到Github-Pages"><a href="#部署Hexo到Github-Pages" class="headerlink" title="部署Hexo到Github Pages"></a>部署Hexo到Github Pages</h2><ul>
<li>安装hexo-deployer-git<br><code>npm install hexo-deployer-git --save</code></li>
<li>修改博客配置文件<br>找到你的hexo文件夹里的_config.yml文件, 用记事本打开，在文件末尾找到Deployment部分，修改成：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: git@github.com:你的用户名&#x2F;你的用户名.github.io.git</span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure></li>
<li>部署<br><code>hexo d</code><br>打开你的博客站点<code>用户名.github.io</code>，如果跟本地静态一样显示Hexo的主题博客模板Hello World则部署成功</li>
</ul>
<h2 id="博客个性化设置"><a href="#博客个性化设置" class="headerlink" title="博客个性化设置"></a>博客个性化设置</h2><ul>
<li>主题更换<ol>
<li>到<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>里面找一款喜欢的主题，点进去找到安装说明。</li>
<li>比如我们想更换为nexT主题，我们只需要在Git Bash进入到hexo文件夹, 然后执行<br><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li>
<li>如果文件下载成功我们会在hexo/themes里面找到next文件夹<br>我们只需要在hexo的_configu.yml文件里面Theme: 后面的landscape改成next</li>
<li>执行<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code><br>然后我们就可以把我们的博客成nexT主题</li>
<li>后续的个性化设置比如增加社交联系方式，更换主题样式等等可以在theme\next_config.yml文件中修改，文件里注释写得很明白</li>
<li>如需要更多的优化，可以在<a href="https://zhuanlan.zhihu.com/p/33616481">Hexo搭建的GitHub博客之优化大全</a>中找到</li>
<li>要支持latex公式，可以按照<a href="https://wangcong.net/article/HexoWihLaTeX.html">Hexo中LaTeX公式渲染</a>中配置</li>
</ol>
</li>
</ul>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ul>
<li>在hexo目录下执行<br><code>hexo new &quot;name&quot;</code><br>该命令会在hexo\sorce_post下新建一个name.md文件,在这个md文件中写入内容</li>
<li>执行<br><code>hexo g</code><br><code>hexo d</code><br>则可以发布</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>链表知识总结</title>
    <url>/2021/03/10/%E9%93%BE%E8%A1%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表是一个线性的数据结构，存放链表的元素的地址是不连续的。链表的节点有两部分组成，分别是数据域和指针域。链表有单链表、双链表、单向循环链表、双向循环链表。<br><img src="/.io//linklist.png" alt="单链表"></p>
<h2 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h2><ul>
<li>动态分配内存</li>
<li>易插入、删除</li>
<li>无空间限制</li>
<li>内存利用率高</li>
</ul>
<h2 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h2><ul>
<li>指针域额外的空间开销</li>
<li>不能随意访问节点</li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>查找：O(n)<br>插入删除：O(1)</p>
]]></content>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解Message Queue(MQ)</title>
    <url>/2021/10/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Message-Queue-MQ/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>

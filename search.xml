<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>basic quantum theory</title>
    <url>/2021/03/06/basic-quantum-theory/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当年在上大学物理的时候的课程项目要求每个人都做一下物理学前沿知识的报告，我的小组选了Quantum Computation这一个课题。在这个报告中我主要负责Quantum Computation涉及到的一些基本的Quantum Mechanics的知识，其中的大部分内容总结自Dirac的《The Principles of Quantum Mechanics》和量子计算的bible《Quantum Computation and Quantum Information》。这是我这篇报告的由来。<br><span id="more"></span></p>
<h2 id="正文部分"><a href="#正文部分" class="headerlink" title="正文部分"></a>正文部分</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Quantum mechanics is the science of the very small. It explains the behavior of matter and its interactions with energy on the scale of atoms and subatomic particles. By contrast, classical physics only explains matter and energy on a scale familiar to human experience, including the behavior of astronomical bodies such as the Moon. Classical physics is still used in much of modern science and technology. However, towards the end of the 19th century, scientists discovered phenomena in both the large (macro) and the small (micro) worlds that classical physics could not explain.The desire to resolve inconsistencies between observed phenomena and classical theory led to two major revolutions in physics that created a shift in the original scientific paradigm: the theory of relativity and the development of quantum mechanics</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>As in classical mechanics, the state of a particle at any given time is specified by two variables position an momentum. If we know these quantities, we can get all the information of the system we want to measure. For example, energy is just some function of position and momentum. We can calculate it if we know the position and momentum. However, this is impossible in quantum mechanics. In atom scale, according to the uncertainty principle, we can’t specify the position and momentum at the same time. How can can we specify the state of a system? By the Copenhagen interpretation, a state of a particle is completely specified by a complex wave function $\ket{\psi}$ and it is described to be a probability amplitude, whose square modulus gives the probability density of finding the particle at point x at time t.</p>
<p>A mixture of quantum states is also a quantum state. Quantum states that cannot be writtten as a mixtrue of other states are called pure quantum states, all other states are called mixed quantum state.</p>
<p>Mathematically, a pure quantum state can be represented by a ray in a Hilbert space over the complex numbers. The ray is a set of nonzero vecctor differing by just a complex factor; any of them can be chosen as a state vector to represent the ray and thus the state. A unit vector is usually picked, but its phase factor can be chosen freely anyway. Nevertheless, such factors are important when state vectors are added together to form a superposition.</p>
<p>A mixed quantum state corresponds to a probabilistic mixture of pure state; however, different distribution of pure states can generate equavalent mixed states. Mixed states are describe by density matrices. A pure state can also be recast as a density matrix; in this way, pure statee can be represented as a subset of more general mixed states.</p>
<h3 id="Bracket-Notaion"><a href="#Bracket-Notaion" class="headerlink" title="Bracket Notaion"></a>Bracket Notaion</h3><p>The absence of a state is represented by the null vector $\ket{0}$ in ket space. The null vector has the fairly obvious property that. $\ket{A}+\ket{0}=\ket{A}$</p>
<p>Now we know that any plane polarized state of a photon can be represented as a linear superposition of two orthogonal polarization states in wichi the weights are real numbers. Suppose we want to construct a circular polarized photon state. Remind that a circularly polarized wave is a superposition of two waves of equal amplitude, plane polarized in the X-direction and a photon polarized in the y-direction, with equal weights given to the two states. To descrive a circularly polarized photon, we can use complex numbers to simultaneously represent the weighting and relative phase phase in a linear superposition. Suppose state B represents the photon polarizing in the x-direction, state C represents the photon polarizing in the y-direction, written as $\ket{B}+i\ket{C}$. Then we can conclude: a general elliptically polarized photon is represeted by $c_1\ket{B}+c_2\ket{C}$ where $c_1 and c_2$ are complex numbers. It implies that a ket space must be a complex vector space.</p>
<p>Any ket vector that is expressible linearly in terms of cortain orthers is said to be dependent on them. Likewise, a set of ket vecotrs are termed independent if none of them are expressible linearly interms of them. The dimension of a ket space is equivalent to the number of independent ket vectors it contains. If there are N independent states then the possible states of the system are represtned as an N-dimensional ket space. Remind some microscopic sysyems have an infinite number of independent states(e.g.,a particle in an infinite, one dimensional, potential well). The possible states are represented as a ket in a ket space whose dimention are infinite.<br>In conclusion, the state of a general microspopic system can be represented as a complex vector space of infinite dimension. Such a space is called  Hilbert space.</p>
<p>Imagine a general functional, label F, acting on a general ket vector, lavel A, and spitting out a general complex number $\phi_A$. This process is represented by writing $\bra{F}(\ket{A})=\phi_A$. Suppose there is a linear functional functionals, satisfies $\bra{F}(\ket{A}+\ket{B})=\braket{F|A}+\braket{F|B}$ where $\ket{A}$ and $\ket{B}$ are any two kets in a given Hilbert space. In a Hilbert space, a general ket vector can be written as $\sum_{i=1}^Na_i\ket{i}$ where $\ket{i}$(i=1,2,3,…,n) represents n independent ket vector in this space, $a_i$ is an arbitrary complex number. Then the functional $\braket{F|A}=\sum_{i=1}^Nf_ia_i$ where $f_i$ are a set of complex numbers relating to the functional. Define n basis of functionals $\bra{i}$ (i=i,2,3,…,n) which satisfy $\braket{i|j}=\delta_{ij}$.Then we get $\bra{F}=\sum_{i=1}^Nf_i\bra{i}$. This implies that the set of all possible linear functionals acting on a n-dimentional ket space is itself an n-dimensional vector space. This type of vector space is called bra space. The vector in this space are called bra vectors. Bra space is an example of what mathematicians call a dual space.  It is dual to the original ket space.</p>
<p>For a general ket vector $A$, the corresponding bra is written as <script type="math/tex">\bra{A}=\sum_{i=1}^Na_i^*\bra{i}</script> where $a_i^*$ are the complex conjugate of $a_i$. Given a ket $\ket{A}$, which is not the null ket, we can define a normalized $\ket{\tilde{A}}$ where $\braket{\tilde{A}|\tilde{A}}=1$. Since $\ket{A}$ and $c\ket{A}$ represent the same physical state (we can not form a new state by superposing a state with itself), it makes sense to require that all kets corresponding to physical states have unit norms.</p>
<h3 id="Wave-Function"><a href="#Wave-Function" class="headerlink" title="Wave Function"></a>Wave Function</h3><p>A wave function in quantum physics is a mathematical description of the quantum state of an isolated quantum system. The wave function is a complex-valued probability amplitude, whose square modulus gives the probability density at a point x. Since we have wave function is complex value, only its relative phase and relative magnitude can be measured. We have to apply quatum operator, whose eigenvalues corresponding to sets of possible results of measurements, to the wave function $\psi$ an calculate the statistical distribution for measurable quantities. The most common symbols for a wave function are the Greek letter $\psi$</p>
<p>Given a basis kets $\ket{k_i}$ of Hilbert space, any ket $\ket{\psi}$ can be written as $\ket{\psi}=\sum_{i=1}^nc_i\ket{k_i}$ where $c_i$ are complex numbers. If the basis is chosen to be orthonormal, then $c_i=\braket{k_i|\psi}$. If $\ket{k_i}$ is eigenstates of an observable with eigenvalue $c_i$, and the observable is measured on the normalized state$\ket{\psi}$, then the probability that the result of the measurement is $k_i$ is $|c_i|^2$.</p>
<p>A particular importan example is the position basis, which is the basis consisting of eigenstates $\ket{\textbf{r}}$ with eigenvalue $\textbf{r}$ of the observable which corresponds to measure position. If these eigenstates are nondegenerate, then the ket $\ket{\psi}$ is associate with a complex-value wave function of there-dimentional space $\psi(\textbf{r})=\braket{\textbf{r}|\psi}$. Simlilarly, the probability density of the particle being found at position $\textbf{r}$ is $|\psi(\textbf{r})|^2$ and the normalized state have $\int d^3\textbf{r}|\psi(\textbf{r})|^2=1$.</p>
<h3 id="Superposition"><a href="#Superposition" class="headerlink" title="Superposition"></a>Superposition</h3><p>If we take any atomic system, there will be many possible motions of the particles consistent with the law of forcee. Each such motion is called a state of the system. A state of a system may be defined as an undistrubuted motion that is whithout mutual interference or contradiction. The general principle of superposition of quantum mechanics applied to the states of any one dynamical system. It requires us to assume that between these states there exist peculiar repationships wuch that whenever the system is definitely in one state we can consider as being partly in each of two or more other states.</p>
<p>When a state is formed by the superposition of other states. As we obserbe, the result shows that the system sometimes in one state, sometimes in another state. The result can’t be determined though the obseervation made. It is the law of nature. The principle was described by Paul Dirac as follows:</p>
<blockquote>
<p>The non-classical nature of the superposition process is brought out clearly if we consider the superpostion of two states, A and B, such that there exists an observation which, when made on the system in states A, is certain to lead to one particular result a.And when made on the system in state B is certain to lead to some different result b. What will be the result of the observation when made on the system in the superposed state? The answer is that  the result will be somtimes a and sometimes b, according to a probability law depending on the relative weights of A and B in the superposition process. It will never be different from both a and b. The intermediate character of the state formed by superposition thus expresses itself throught  the probability of a particular result for an observation being intermediate between the corresponding probabilities for the original states, not throught the result itself being intemediate between the corresponding result for the original states.</p>
</blockquote>
<p>As an example, suppose there are two eigenstates $\ket{\psi_i}$ and $\ket{\psi_2}$, the superposition of them is their linear combination $c_1\ket{\psi_1}+c_2\ket{\psi_2}$. If we make an observation on the system. The wave function of the system will collapse to an eigenstate of the observable randomly. The probability ralating to the eigenstate $\ket{\psi_1}$ is $|c_1|^2$, the probability relating to eigensteate $c_2$ is $|c_2|^2$. </p>
<h3 id="Entanglement"><a href="#Entanglement" class="headerlink" title="Entanglement"></a>Entanglement</h3><p>By definition, quantum entanglement is a physical phenomenon which occurs when pairs or groups of particles are generated or interact in ways such that the quantum state of each that the quantum state of each particle cannot be described independently of the state of the others, even when the particles are separated by large distance.</p>
<p>So far, we have assumed that the system is made of a single component. Suppose a system is made of two component: one in a Hilbert space $H_1$ and another component in another Hilber space $H_2$. Then the system as a whole live in a Hilbert space $H=H_1\otimes H_2$. The general vector in this space is written as $\ket{\psi}=\sum_{i,j}c_{ij}\ket{e_1,i}\otimes\ket{e_2,j}$ where $\ket{e_a,i}$(a=1,2) is an orthonormal basis in $H_a$ and $\sum_{i,}|c_{ij}|^2=1$. A state $\ket{\psi}\in H$ written as a tensor product of two vector $\ket{\psi}=\ket{\psi_1}\otimes\ket{\psi_2}$ is called a tensor product state or a separable state. Non-separable states are called entangle state.</p>
<p>The set of separate states have dimension $dimH_1+dimH_2$. The total space $H$ has dimension $dimH_1dimH_2$.When the dimension of original Hilbert space is large,we have $dimH_1dimH_2$&gt;$dimH_1+dimH_2$. Then most states in the total space are entangled.</p>
]]></content>
      <categories>
        <category>physics</category>
      </categories>
      <tags>
        <tag>quantum mechanics</tag>
        <tag>quantum computation</tag>
      </tags>
  </entry>
  <entry>
    <title>用Github pages和Hexo搭建自己的个人博客</title>
    <url>/2021/03/06/%E7%94%A8Github-pages%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://pages.github.com/">Github Pages</a>是一个静态站点托管服务, 用户可以可以从Github直接获取HTML, CSS, Java Script文件, 用户可以用这些文件来发布网页。<br><a href="https://hexo.io/">Hexo.io</a>是一个基于Node.js的快速、简单、功能强大的博客框架。<br>本门将介绍如何使用Hexo + Github Pages搭建个人博客。<br><span id="more"></span></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载和安装Node.js和Git</p>
<ul>
<li>Node.js下载地址: <a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li>
<li>Git下载地址: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<h2 id="Git连接Github"><a href="#Git连接Github" class="headerlink" title="Git连接Github"></a>Git连接Github</h2><p>打开Git Bash</p>
<ul>
<li>设置用户名和邮箱<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub邮箱&quot;</code></li>
<li>生成SSH密钥<br><code>ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot;</code></li>
<li>为Github账户添加SSH密钥<br>公钥默认保存在 <code>C:\Users\用户名\.ssh</code>目录中, 用记事本打开 id_rsa.pub，复制内容。<br>点开github页面右上角头像,在Settings-&gt;SSH and GPG keys中点击New SSH key, 随便取个标题, 将复制的公钥粘贴进去, 点击Add SSH key </li>
<li>验证连接<br>打开Git Bash, 输入<br><code>ssh -T git@github.com</code><br>如果显示”You’ve successfully authenticated, but…”则连接成功</li>
</ul>
<h2 id="创建Github-Pages-Repository"><a href="#创建Github-Pages-Repository" class="headerlink" title="创建Github Pages Repository"></a>创建Github Pages Repository</h2><ul>
<li>点开github页面右上角旁边的加号，选择New repository</li>
<li>Repository name填上 <code>用户名.github.io</code></li>
<li>勾选 Add a README file</li>
<li>点击 Create repository</li>
</ul>
<h2 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h2><ul>
<li>找一个地方新建文件夹, 命名为hexo用来存放Hexo程序</li>
<li>打开Git CMD 进入到hexo的文件夹(注意这里不是Git Bash, 如果用Git Bash可能会碰到奇奇怪怪的问题)</li>
<li>npm安装hexo<br><code>npm install -g hexo-cli</code></li>
<li>hexo文件下载<br><code>hexo init</code></li>
<li>生成静态文件<br><code>hexo g</code></li>
<li>部署到本地服务器4000端口<br><code>hexo s</code><br>如果访问<code>http://localhost:4000</code>看到Hexo默认页面的Hello World则本地博客安装成功</li>
</ul>
<h2 id="部署Hexo到Github-Pages"><a href="#部署Hexo到Github-Pages" class="headerlink" title="部署Hexo到Github Pages"></a>部署Hexo到Github Pages</h2><ul>
<li>安装hexo-deployer-git<br><code>npm install hexo-deployer-git --save</code></li>
<li>修改博客配置文件<br>找到你的hexo文件夹里的_config.yml文件, 用记事本打开，在文件末尾找到Deployment部分，修改成：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: git@github.com:你的用户名&#x2F;你的用户名.github.io.git</span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure></li>
<li>部署<br><code>hexo d</code><br>打开你的博客站点<code>用户名.github.io</code>，如果跟本地静态一样显示Hexo的主题博客模板Hello World则部署成功</li>
</ul>
<h2 id="博客个性化设置"><a href="#博客个性化设置" class="headerlink" title="博客个性化设置"></a>博客个性化设置</h2><ul>
<li>主题更换<ol>
<li>到<a href="https://hexo.io/themes/">https://hexo.io/themes/</a>里面找一款喜欢的主题，点进去找到安装说明。</li>
<li>比如我们想更换为nexT主题，我们只需要在Git Bash进入到hexo文件夹, 然后执行<br><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li>
<li>如果文件下载成功我们会在hexo/themes里面找到next文件夹<br>我们只需要在hexo的_configu.yml文件里面Theme: 后面的landscape改成next</li>
<li>执行<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code><br>然后我们就可以把我们的博客成nexT主题</li>
<li>后续的个性化设置比如增加社交联系方式，更换主题样式等等可以在theme\next_config.yml文件中修改，文件里注释写得很明白</li>
<li>如需要更多的优化，可以在<a href="https://zhuanlan.zhihu.com/p/33616481">Hexo搭建的GitHub博客之优化大全</a>中找到</li>
<li>要支持latex公式，可以按照<a href="https://wangcong.net/article/HexoWihLaTeX.html">Hexo中LaTeX公式渲染</a>中配置</li>
</ol>
</li>
</ul>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ul>
<li>在hexo目录下执行<br><code>hexo new &quot;name&quot;</code><br>该命令会在hexo\sorce_post下新建一个name.md文件,在这个md文件中写入内容</li>
<li>执行<br><code>hexo g</code><br><code>hexo d</code><br>则可以发布</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ事务消息机制源码解析</title>
    <url>/2021/10/20/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="事务消息机制源码解析"><a href="#事务消息机制源码解析" class="headerlink" title="事务消息机制源码解析"></a>事务消息机制源码解析</h1><p>代码解析：</p>
<ol>
<li>发送事务消息入口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.transactionListener) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;TransactionListener is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.setTopic(NamespaceUtil.wrapNamespace(<span class="keyword">this</span>.getNamespace(), msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>TransactionListenner</code>为空则抛出异常，否则调用<code>defaultMQProducerImpl</code>类下的<code>sendMessageInTransaction</code>方法发送事务消息</p>
<ol>
<li><p>发送事务消息具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        TransactionListener transactionListener = getCheckListener();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;tranExecutor is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ignore DelayTimeLevel parameter</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() != <span class="number">0</span>) &#123;</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;send message Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">        Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        msg.putUserProperty(<span class="string">&quot;__transactionId__&quot;</span>, sendResult.getTransactionId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(transactionId)) &#123;</span><br><span class="line">                        msg.setTransactionId(transactionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                        localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Used new transaction API&quot;</span>);</span><br><span class="line">                        localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                        localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;executeLocalTransactionBranch return &#123;&#125;&quot;</span>, localTransactionState);</span><br><span class="line">                        log.info(msg.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;executeLocalTransactionBranch exception&quot;</span>, e);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                    localException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">            <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">            <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.endTransaction(msg, sendResult, localTransactionState, localException);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;local transaction execute &quot;</span> + localTransactionState + <span class="string">&quot;, but end broker transaction failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">        transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">        transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">        transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">        transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">        <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在发送前先设置消息的PROPERTY_TRANSACTION_PREPARED属性为true，指定这是个半消息。同时设置消息的PROPERTY_PRODUCER_GROUP属性值为当前消息的生产者组是哪个。然后向Broker发消息。</p>
<ol>
<li>Broker接收生产者发送消息请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.processor;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;receive SendMessage request command, &#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimstamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">&quot;broker unable to service, until %s&quot;</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    String clusterName = <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerClusterName();</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)</span><br><span class="line">        &amp;&amp; !(msgInner.getReconsumeTimes() &gt; <span class="number">0</span> &amp;&amp; msgInner.getDelayTimeLevel() &gt; <span class="number">0</span>)) &#123; <span class="comment">//For client under version 4.6.1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">&quot;the broker[&quot;</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                    + <span class="string">&quot;] sending transaction message is forbidden&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Broker</code>收到请求后，判断消息是不是半消息，如果是则调用<code>TransactionMessageService</code>类的<code>prepareMessage</code>方法，否则走普通消息的逻辑，即调用<code>MessageStore</code>的<code>putMessage</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">prepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalMessageBridge.putHalfMessage(messageInner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransactionalMessageBridge</code>是桥接类，作用主要是封装事务消息，然后用<code>MessageStore</code>的<code>putMessage</code>方法对半消息持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction.queue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">            String.valueOf(msgInner.getQueueId()));</span><br><span class="line">        msgInner.setSysFlag(</span><br><span class="line">            MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">        msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">        msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">        <span class="keyword">return</span> msgInner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在消息持久化之前，先将消息原本的<code>Topic</code>跟<code>QueueId</code>备份，然后将消息的主题设置成<code>RMQ_SYS_TRANS_HALF_TOPIC</code>，将<code>QueueID</code>固定为0。注意此时的半消息对消费者是不可见的。半消息持久化完成后，会把消息发送的结果返回给生产者。</p>
<ol>
<li>收到消息发送成功响应，生产者执行本地事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    TransactionListener transactionListener = getCheckListener();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;tranExecutor is null&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ignore DelayTimeLevel parameter</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getDelayTimeLevel() != <span class="number">0</span>) &#123;</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;send message Exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">    Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    msg.putUserProperty(<span class="string">&quot;__transactionId__&quot;</span>, sendResult.getTransactionId());</span><br><span class="line">                &#125;</span><br><span class="line">                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(transactionId)) &#123;</span><br><span class="line">                    msg.setTransactionId(transactionId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;Used new transaction API&quot;</span>);</span><br><span class="line">                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                    localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;executeLocalTransactionBranch return &#123;&#125;&quot;</span>, localTransactionState);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;executeLocalTransactionBranch exception&quot;</span>, e);</span><br><span class="line">                log.info(msg.toString());</span><br><span class="line">                localException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endTransaction(msg, sendResult, localTransactionState, localException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;local transaction execute &quot;</span> + localTransactionState + <span class="string">&quot;, but end broker transaction failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">    transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">    transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">    transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">    transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">    <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息发送成功，生产者会调用<code>TransactionListener</code>的<code>executeLocalTransaction</code>方法执行本地事务。<code>localTransactionState</code>初始化状态为<code>UNKNOWN</code>，事务执行完成后会返回<code>COMMIT_MESSAGE, ROLLBACK_MESSAGE, UNKNOWN其一。如果发送失败，说明半消息没有持久化成功。此时设置</code>LocalTransactionState<code>为</code>ROLLBACK_MESSAGE<code>，但后续执行</code>RollBackMessage`的时候会提示找不到半消息。</p>
<ol>
<li>结束事务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.impl.producer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendResult sendResult,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Throwable localException)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MessageId id;</span><br><span class="line">    <span class="keyword">if</span> (sendResult.getOffsetMsgId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line">    String transactionId = sendResult.getTransactionId();</span><br><span class="line">    <span class="keyword">final</span> String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line">    EndTransactionRequestHeader requestHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">    requestHeader.setTransactionId(transactionId);</span><br><span class="line">    requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">    <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNKNOW:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doExecuteEndTransactionHook(msg, sendResult.getMsgId(), brokerAddr, localTransactionState, <span class="keyword">false</span>);</span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">    requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">    String remark = localException != <span class="keyword">null</span> ? (<span class="string">&quot;executeLocalTransactionBranch exception: &quot;</span> + localException.toString()) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把<code>transactionID</code>、<code>CommitLogOffset</code>、<code>CommitOrRollBack</code>、<code>ProducerGroup</code>、<code>TranStateTableOffset</code>(<code>queueOffset</code>)这一系列参数写到请求的头部，然后发到Broker。</p>
<p>在Boker端会用<code>EndTransactionProcessor</code>去处理请求。</p>
<ol>
<li>EndTransactionProcessor</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.processor;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> EndTransactionRequestHeader requestHeader =</span><br><span class="line">        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Transaction request:&#123;&#125;&quot;</span>, requestHeader);</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;Message store is slave mode, so end transaction is forbidden. &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getFromTransactionCheck()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, but it&#x27;s pending status.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, the producer commit the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;Check producer[&#123;&#125;] transaction state, the producer rollback the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;The producer[&#123;&#125;] end transaction in sending message,  and it&#x27;s pending status.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: &#123;</span><br><span class="line">                LOGGER.warn(<span class="string">&quot;The producer[&#123;&#125;] end transaction in sending message, rollback the message.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;RequestHeader: &#123;&#125; Remark: &#123;&#125;&quot;</span>,</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()),</span><br><span class="line">                    requestHeader.toString(),</span><br><span class="line">                    request.getRemark());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OperationResult result = <span class="keyword">new</span> OperationResult();</span><br><span class="line">    <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCode(result.getResponseCode());</span><br><span class="line">    response.setRemark(result.getResponseRemark());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">checkPrepareMessage</span><span class="params">(MessageExt msgExt, EndTransactionRequestHeader requestHeader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String pgroupRead = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">            <span class="keyword">if</span> (!pgroupRead.equals(requestHeader.getProducerGroup())) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The producer group wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msgExt.getQueueOffset() != requestHeader.getTranStateTableOffset()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The transaction state table offset wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msgExt.getCommitLogOffset() != requestHeader.getCommitLogOffset()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">                response.setRemark(<span class="string">&quot;The commit log offset wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">&quot;Find prepared transaction message failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">endMessageTransaction</span><span class="params">(MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">        MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line">        msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(msgExt.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());</span><br><span class="line">        msgInner.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line">        msgInner.setTransactionId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        TopicFilterType topicFilterType =</span><br><span class="line">            (msgInner.getSysFlag() &amp; MessageSysFlag.MULTI_TAGS_FLAG) == MessageSysFlag.MULTI_TAGS_FLAG ? TopicFilterType.MULTI_TAG</span><br><span class="line">                : TopicFilterType.SINGLE_TAG;</span><br><span class="line">        <span class="keyword">long</span> tagsCodeValue = MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());</span><br><span class="line">        msgInner.setTagsCode(tagsCodeValue);</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC);</span><br><span class="line">        MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID);</span><br><span class="line">        <span class="keyword">return</span> msgInner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Broker处理<code>endTransaction</code>请求时，先根据<code>MessageSysFlag</code>是<code>TRANSACTION_COMMIT_TYPE</code>还是<code>TRANSACTION_ROLLBACK_TYPE</code>。</p>
<ul>
<li>如果<code>MessageSysFlag</code>是<code>TRANSACTION_COMMIT_TYPE</code>, 则根据调用<code>TransactionMessageService</code>类的<code>commitMessage</code>方法。从语义上来说<code>commitMessage</code>是提交消息，其真实逻辑是根据返回的<code>result</code>的<code>commtLogOfset</code>从<code>commitLog</code>获取半消息。如果结果返回成功了，那么先调用<code>checkPreparedMessage</code>去检查半消息的合法性，半消息的<code>producrGroup</code>、<code>TranStateTableOffset</code>、<code>commitLogOffset</code>应该与请求头的参数相同，同时半消息不应该为空。如果半消息没问题，那么就调用<code>endMessageTransaction</code>方法。将半消息的<code>Topic</code>和<code>queueId</code>还原成在属性中备份的真实值。回到<code>processRequest</code>方法，因为在半消息持久化前，<code>MessageSysFlag</code>被设置成<code>TRANSACTION_NOT_TYPE</code>, 现在要commit消息，需要把<code>MessageSysFlag</code>改成<code>TRANSACTION_COMMIT_TYPE</code>，然后调用<code>sendFinalMessage</code>将还原后的消息持久化，调用<code>commitLogDispatcherBuildComsumer.dispatch</code>更新<code>topic</code>的<code>consumerQueue</code>，经过这些过程消息对消费者可见。<code>sendFinalMessage</code>执行完以后调用<code>TransactionService</code>的<code>deletePrepareMessage</code>将半消息删除。这个删除不是真正意义上的删除，而是构建一个<code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code>队列，<code>queueID</code>跟半消息的一样都是0，然后把消息插到队列里面去，消息内容是半消息的<code>queueOffset</code>，并将<code>TAGS</code>属性设为d(d也就是<code>TransactionalMessageUtil.REMOVETAG</code>)，标记这个消息的状态是已经<code>commit</code>或者<code>rollback</code>了。除此之外，还会创建一个哈希表<code>opQueueMap</code>, 让半消息的队列<code>messageQueue</code>映射到<code>opQueue</code>。</li>
<li>如果<code>MessageSysFlag</code>是<code>TRANSACTION_ROLLBACK_TYPE</code>。先调用<code>rollbackMessage</code>，根据返回的<code>result</code>获取半消息。检查半消息合法性后，删除半消息，逻辑跟前面的一样。</li>
</ul>
<ol>
<li>事务回查机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Start transaction check service thread!&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(checkInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;End transaction check service thread!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">        <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;Begin to check prepare message, begin time:&#123;&#125;&quot;</span>, begin);</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">        log.info(<span class="string">&quot;End to check prepare message, consumed time:&#123;&#125;&quot;</span>, System.currentTimeMillis() - begin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.broker.transaction.queue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> transactionTimeout, <span class="keyword">int</span> transactionCheckMax,</span></span></span><br><span class="line"><span class="function"><span class="params">    AbstractTransactionalMessageCheckListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">        Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">        <span class="keyword">if</span> (msgQueues == <span class="keyword">null</span> || msgQueues.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The queue of topic is empty :&quot;</span> + topic);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;Check topic=&#123;&#125;, queues=&#123;&#125;&quot;</span>, topic, msgQueues);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">            log.info(<span class="string">&quot;Before check, the queue=&#123;&#125; msgOffset=&#123;&#125; opOffset=&#123;&#125;&quot;</span>, messageQueue, halfOffset, opOffset);</span><br><span class="line">            <span class="keyword">if</span> (halfOffset &lt; <span class="number">0</span> || opOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;MessageQueue: &#123;&#125; illegal offset read: &#123;&#125;, op offset: &#123;&#125;,skip this queue&quot;</span>, messageQueue,</span><br><span class="line">                    halfOffset, opOffset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Long&gt; doneOpOffset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            HashMap&lt;Long, Long&gt; removeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The queue=&#123;&#125; check msgOffset=&#123;&#125; with opOffset=&#123;&#125; failed, pullResult is null&quot;</span>,</span><br><span class="line">                    messageQueue, halfOffset, opOffset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// single thread</span></span><br><span class="line">            <span class="keyword">int</span> getMessageNullCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> newOffset = halfOffset;</span><br><span class="line">            <span class="keyword">long</span> i = halfOffset;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Queue=&#123;&#125; process time reach max=&#123;&#125;&quot;</span>, messageQueue, MAX_PROCESS_TIME_LIMIT);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (removeMap.containsKey(i)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;Half offset &#123;&#125; has been committed/rolled back&quot;</span>, i);</span><br><span class="line">                    Long removedOpOffset = removeMap.remove(i);</span><br><span class="line">                    doneOpOffset.add(removedOpOffset);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">                    MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                    <span class="keyword">if</span> (msgExt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getMessageNullCount++ &gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;No new msg, the miss offset=&#123;&#125; in=&#123;&#125;, continue check=&#123;&#125;, pull result=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                                messageQueue, getMessageNullCount, getResult.getPullResult());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;Illegal offset, the miss offset=&#123;&#125; in=&#123;&#125;, continue check=&#123;&#125;, pull result=&#123;&#125;&quot;</span>,</span><br><span class="line">                                i, messageQueue, getMessageNullCount, getResult.getPullResult());</span><br><span class="line">                            i = getResult.getPullResult().getNextBeginOffset();</span><br><span class="line">                            newOffset = i;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;</span><br><span class="line">                        listener.resolveDiscardMsg(msgExt);</span><br><span class="line">                        newOffset = i + <span class="number">1</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (msgExt.getStoreTimestamp() &gt;= startTime) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Fresh stored. the miss offset=&#123;&#125;, check it later, store=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                            <span class="keyword">new</span> Date(msgExt.getStoreTimestamp()));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();</span><br><span class="line">                    <span class="keyword">long</span> checkImmunityTime = transactionTimeout;</span><br><span class="line">                    String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != checkImmunityTimeStr) &#123;</span><br><span class="line">                        checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);</span><br><span class="line">                        <span class="keyword">if</span> (valueOfCurrentMinusBorn &lt; checkImmunityTime) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) &#123;</span><br><span class="line">                                newOffset = i + <span class="number">1</span>;</span><br><span class="line">                                i++;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="number">0</span> &lt;= valueOfCurrentMinusBorn) &amp;&amp; (valueOfCurrentMinusBorn &lt; checkImmunityTime)) &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;New arrived, the miss offset=&#123;&#125;, check it later checkImmunity=&#123;&#125;, born=&#123;&#125;&quot;</span>, i,</span><br><span class="line">                                checkImmunityTime, <span class="keyword">new</span> Date(msgExt.getBornTimestamp()));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">                    <span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                        || (opMsg != <span class="keyword">null</span> &amp;&amp; (opMsg.get(opMsg.size() - <span class="number">1</span>).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                        || (valueOfCurrentMinusBorn &lt;= -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        listener.resolveHalfMsg(msgExt);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);</span><br><span class="line">                        log.debug(<span class="string">&quot;The miss offset:&#123;&#125; in messageQueue:&#123;&#125; need to get more opMsg, result is:&#123;&#125;&quot;</span>, i,</span><br><span class="line">                            messageQueue, pullResult);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newOffset = i + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newOffset != halfOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">            <span class="keyword">if</span> (newOpOffset != opOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Check error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">fillOpRemoveMap</span><span class="params">(HashMap&lt;Long, Long&gt; removeMap,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageQueue opQueue, <span class="keyword">long</span> pullOffsetOfOp, <span class="keyword">long</span> miniOffset, List&lt;Long&gt; doneOpOffset)</span> </span>&#123;</span><br><span class="line">        PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == pullResult) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL</span><br><span class="line">            || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is illegal, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue,</span><br><span class="line">                pullResult);</span><br><span class="line">            transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is NO_NEW_MSG, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue,</span><br><span class="line">                pullResult);</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">        <span class="keyword">if</span> (opMsg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;The miss op offset=&#123;&#125; in queue=&#123;&#125; is empty, pullResult=&#123;&#125;&quot;</span>, pullOffsetOfOp, opQueue, pullResult);</span><br><span class="line">            <span class="keyword">return</span> pullResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt opMessageExt : opMsg) &#123;</span><br><span class="line">            Long queueOffset = getLong(<span class="keyword">new</span> String(opMessageExt.getBody(), TransactionalMessageUtil.charset));</span><br><span class="line">            log.debug(<span class="string">&quot;Topic: &#123;&#125; tags: &#123;&#125;, OpOffset: &#123;&#125;, HalfOffset: &#123;&#125;&quot;</span>, opMessageExt.getTopic(),</span><br><span class="line">                opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);</span><br><span class="line">            <span class="keyword">if</span> (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queueOffset &lt; miniOffset) &#123;</span><br><span class="line">                    doneOpOffset.add(opMessageExt.getQueueOffset());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    removeMap.put(queueOffset, opMessageExt.getQueueOffset());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Found a illegal tag in opMessageExt= &#123;&#125; &quot;</span>, opMessageExt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;Remove map: &#123;&#125;&quot;</span>, removeMap);</span><br><span class="line">        log.debug(<span class="string">&quot;Done op list: &#123;&#125;&quot;</span>, doneOpOffset);</span><br><span class="line">        <span class="keyword">return</span> pullResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事务回查的核心功能是通过<code>TransactionMessageServieImpl</code>的<code>check</code>方法实现的。<code>TransactionMessageCheckServie</code>的<code>run</code>方法会启动一个线程，每隔<code>checkInterval</code>时间执行一次<code>onWaitEnd</code>方法调用<code>check</code>方法。在check方法中，首先根据半消息的<code>topic</code>拿到<code>msgQueue</code>，根据<code>msgQueue</code>拿到<code>opQueue</code>。在前面我们说过，半消息的<code>msgQueue</code>跟<code>opQueue</code>是一一对应的关系。如果<code>opQueueMap</code>为空，则创建一个空的<code>opQueue</code>，把两个队列的对应关系插入到<code>opQueueMap</code>里面。在用<code>halfOffset</code>和<code>opOffset</code>记录各自消费进度后，调用 <code>fillOpRemoveMap</code>去填充<code>removeMap</code>和<code>doneOpOffset</code>。在填充之前先用<code>pullOpMessage</code>从<code>transactionalMessageBridge</code>把从<code>pullOffsetOfOp</code>开始的32个message复制到现在的<code>opQueue</code>里。填充逻辑如下：</p>
<p><img src="/2021/10/20/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20210831214240963.png" alt="image-20210831214240963"></p>
<p>对于半消息队列来说来说 <code>min offset</code>就是当前消费进度，<code>max offset</code>是最后一个消息的offset。对于op消息队列来说，<code>queue offset</code>当前op消息的内容，也就是在半消息中的offset。<code>max offset</code>最大是32，因为我们一次最多pull32个op消息到op消息队列。这个方法会遍历整个op消息队列，每次获取当前消息的内容<code>queue offset</code>然后跟<code>min offset</code>去比对，如果<code>queue offset &lt; min offset</code>说明这个消息已经是已经被处理过了，不用再管。其余的按照key为半消息队列offset， value为op消息队列offset插入removeMap，说明key对应的半消息不需要回查。</p>
<p>在填充完<code>removeMap</code>后会进入一个循环 ，从<code>halfOffset</code>开始去遍历半消息，<code>removeMap</code>的key包含这个offset，说明这个offset对应的半消息已经被commit或者rollback了，不需要回查，执行下一个offset+1对应 半消息的检查。如果是不在<code>removeMap</code>里面，就用<code>needDiscard</code>去判断这个消息有没有超过最大回查次数15次，如果超过15次了那就不查了。同时要判断这个半消息存盘后有没有超过72个小时，因为超过72小时这个半消息会被丢弃。接下来有一个<code>checkImmunityTimeStr</code>，这个是回查免疫时间，就是消息存盘后这个回查免疫时间内是不进行回查的。如果在这个时间内，而且而且是首次回查，就不进行回查。如果是生产者没有设置首次回查免疫时间，如果在免疫时间内就跳过当前半消息以及后续所有的的半消息的回查，因为同一个consumer中的消息是有顺序的。如果前面条件都满足，就调用<code>putBackHalfMsgQueue</code>再次存盘。因为这次回查是否能够确定状态是不知道的，为了下一次回查，将这个半消息再次存盘。然后调用<code>resolveHalfMsg</code>进行回查逻辑。每次回查结束都更新半消息队列和op消息队列。这个while循环是有时间限制的，如果超过时间限制则会跳出循环。</p>
]]></content>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating Systems: Three Easy Pieces阅读笔记(一) Introduction</title>
    <url>/2022/07/27/Operating-Systems-Three-Easy-Pieces%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="1-Operating-System"><a href="#1-Operating-System" class="headerlink" title="1. Operating System"></a>1. Operating System</h2><h3 id="1-Definition"><a href="#1-Definition" class="headerlink" title="(1) Definition"></a>(1) Definition</h3><p>Operating system is a body of software which is responsible for making sure the system operates correctly and efficiently in an easy-to-use manner. Operating system acchieve this goal through a general techenique that we call <strong>virtualization</strong>.</p>
<h3 id="2-Responsibility-of-the-OS"><a href="#2-Responsibility-of-the-OS" class="headerlink" title="(2) Responsibility of the OS"></a>(2) Responsibility of the OS</h3><p>Make it easy to run programs, allow programs to share memory, enable programs to interact with diveces,.etc.</p>
<h3 id="3-Four-Themes-of-This-Book"><a href="#3-Four-Themes-of-This-Book" class="headerlink" title="(3) Four Themes of This Book"></a>(3) Four Themes of This Book</h3><ol>
<li>Virtualization</li>
<li>Concurrency</li>
<li>Persistence</li>
<li>Security</li>
</ol>
<h2 id="2-Virtualzition"><a href="#2-Virtualzition" class="headerlink" title="2. Virtualzition"></a>2. Virtualzition</h2><h3 id="1-Definition-1"><a href="#1-Definition-1" class="headerlink" title="(1) Definition"></a>(1) Definition</h3><p>Transform physical resources into a more general, powerful and easy-to-use virtual form of itself.</p>
<h3 id="2-Virtualizing-The-CPU"><a href="#2-Virtualizing-The-CPU" class="headerlink" title="(2) Virtualizing The CPU"></a>(2) Virtualizing The CPU</h3><p>Turning a single CPU into a seemingly infinite number of CPUs and thus allowing many programs to seemingly run at the same time </p>
<h3 id="3-Virtualizing-The-Memory"><a href="#3-Virtualizing-The-Memory" class="headerlink" title="(3) Virtualizing The Memory"></a>(3) Virtualizing The Memory</h3><p>Each process accesses its own private virtual address space, which the OS somehow maps onto the physical address of the machine.</p>
<h4 id="Note-Physical-Memory-Model"><a href="#Note-Physical-Memory-Model" class="headerlink" title="Note: Physical Memory Model"></a>Note: Physical Memory Model</h4><p>Memory is just an array of bytes; to read memory, one must specify an address to be access the data stored there; to write memory, one must specify the data to be written to the given address.</p>
<h2 id="3-Concurrency"><a href="#3-Concurrency" class="headerlink" title="3. Concurrency"></a>3. Concurrency</h2><h3 id="1-Definition-2"><a href="#1-Definition-2" class="headerlink" title="(1) Definition"></a>(1) Definition</h3><p>A host of problems that arise when working on many things at onces in the same program.</p>
<h3 id="2-Senario"><a href="#2-Senario" class="headerlink" title="(2) Senario"></a>(2) Senario</h3><p>Use two threads to increment a shared variable in a loop. As the number of interation set to 1000, the final value is 2000 as expected. When the number of iteraction set to 100000, the correct answer is not guaranteed.</p>
<h3 id="3-Cause"><a href="#3-Cause" class="headerlink" title="(3) Cause"></a>(3) Cause</h3><p>The increment process takes 3 instructions: load the value of the vairable from memory into a register, increment, store it back to memory. These instructions do not execute atomically.</p>
<h2 id="4-Persistence"><a href="#4-Persistence" class="headerlink" title="4. Persistence"></a>4. Persistence</h2><h3 id="1-File-System"><a href="#1-File-System" class="headerlink" title="(1) File System"></a>(1) File System</h3><p>File System is responsible for storing any files the user creates in a reliable and efficient manner on the disk of the system.</p>
<h3 id="2-Standard-Library"><a href="#2-Standard-Library" class="headerlink" title="(2) Standard Library"></a>(2) Standard Library</h3><p>OS provides uniform library to make it easy to access devices through system calls.</p>
<h3 id="3-Performance-Optimization"><a href="#3-Performance-Optimization" class="headerlink" title="(3) Performance Optimization"></a>(3) Performance Optimization</h3><p>Most file system delay writes for a while, hoping to batch them to a larger group.</p>
<h3 id="4-Reliability-Opimization"><a href="#4-Reliability-Opimization" class="headerlink" title="(4) Reliability Opimization"></a>(4) Reliability Opimization</h3><p>To handle the problems of system crashes during writes, most file system incorporate some kind of intricate write protocol like copy-on-write to ensure that if failure occurs during writing sequence, the system can recover to a reasonable state afterwards.</p>
<h2 id="5-Design-Goals-of-Operating-System"><a href="#5-Design-Goals-of-Operating-System" class="headerlink" title="5. Design Goals of Operating System"></a>5. Design Goals of Operating System</h2><ul>
<li><strong>Abstraction</strong></li>
<li>Minimize the overhead</li>
<li>Protection between application(Isolation)</li>
<li>Reliability</li>
<li>Security</li>
<li>Mobility</li>
<li>Energy-efficiency</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
</search>
